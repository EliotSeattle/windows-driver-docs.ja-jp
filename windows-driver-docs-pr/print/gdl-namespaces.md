---
title: GDL 名前空間
description: GDL 名前空間
ms.assetid: 111bc393-a44a-4c42-98ef-36f6f225b8a0
keywords:
- GDL WDK、名前空間
- WDK GDL 名前空間
- WDK GDL、例の名前空間
- 名前なし名前空間の WDK GDL
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 0e03a3f2ad6a91d8c2bf6d84159bf08710d1374d
ms.sourcegitcommit: a33b7978e22d5bb9f65ca7056f955319049a2e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/31/2019
ms.locfileid: "56548898"
---
# <a name="gdl-namespaces"></a>GDL 名前空間


GDL パーサーでは、2 回以上定義する同じ名前のテンプレートは許可されません。 2 つの個別に作成したテンプレート ファイルは、テンプレートに同じ名前を使用して、誤ってと GDL ファイルでこれらのテンプレート ファイルの両方を含むが停止します。

名前の衝突の問題を回避するには、GDL は名前空間をサポートしています。 ヘッダー ファイルの作成者が各テンプレートとマクロ定義内で定義全体を囲むことでに属している名前空間を指定できます、 \*DefineInNameSpace コンストラクトします。 このコンス トラクターのインスタンス名は、名前空間になるように指定されているシンボルのすべての含まれている定義に属します。 2 つ以上の入れ子になった内で、定義が存在する場合\*DefineInNameSpace コンストラクトと、それが属する最も内側で定義されている名前空間にのみ\*DefineInNameSpace コンストラクトします。 内で、定義が存在しない場合\*DefineInNameSpace コンストラクトと、既定または名前空間の「名前なし」に割り当てられます。

テンプレートまたはマクロのコンストラクトの本体を構成するエントリが個別に囲まれている場合\*DefineInNameSpace コンストラクトと、パーサーは配置しませんこれら個々 のエントリで、新しい名前空間、個々 のエントリが個別ではないため、定義では、別の名前空間内に存在できないためです。 ブロックのマクロの入れ子になったマクロ定義を許可して、他の名前空間に入れ子になったこれらの定義を割り当てることができます。 ただし、入れ子になった定義の名前空間の変更は拡張されませんその有効期間。 入れ子になったマクロ定義で定義された、入れ子のレベル内でのみ参照できます。

名前空間で修飾名または修飾されていない形式では、テンプレート、またはマクロの名前を参照できます。 テンプレートまたはマクロの名前を修飾するために名前空間の名前は、単に介在するコロンを持つテンプレート、またはマクロ名にプレフィックス (たとえば、 *Namespace*:*MacroName*)。

**注**  シンボル名の値として指定されている\*テンプレート、\*マクロ、または\*BlockMacro 定義は、名前空間で修飾することはできません。 のみを使用して、定義の名前空間を定義できます\*DefineInNameSpace します。

 

たとえば、"TEMPNAME"というテンプレートは、"NSName"という名前空間内で定義されていますが、後にそのテンプレート参照できます別のテンプレート定義でとして次のコード例は、名前空間で修飾フォームを使用しています。

```cpp
*DefineInNameSpace: NSName
{
    *Template:  TEMPNAME
    {
        *%  member attributes
    }
}
```

このテンプレートは、次のコード例のように名前空間で修飾の構文を使用して、別のテンプレートから今すぐ参照できます。

```cpp
*Template:  ANOTHER_TEMPLATE
{
    *Inherits: NSName:TEMPNAME
}
```

テンプレート参照の大部分は、同じ名前空間を参照かどうかまたは 2 つ以上の名前空間内で参照されるテンプレート名の間で名前の競合がない場合は、名前空間修飾子を省略し、テンプレートの名前のみを指定してに依存します一致するテンプレートが見つかるまで、名前空間の一覧を検索するパーサー。

内の 1 つまたは複数の GDL エントリを囲むことで名前空間の一覧が指定された\*UsingNameSpace を構築します。 これらの参照の解決に影響を受けるしてこれらのエントリには、テンプレートまたはマクロを修飾されていない参照が含まれて場合、 \*UsingNameSpace を構築します。 このコンス トラクターのインスタンス名として指定されているシンボルは、検索する名前空間を識別します。

複数の構造を入れ子にして、複数の名前空間を指定できます。 検索順序は、最も内側で始まる\*UsingNameSpace 構築し、外向きが続行されます。 テンプレート定義で指定された名前空間が見つかった場合は、検索は停止し、そのテンプレートが使用されます。 パーサーがそれを囲む各でという名前空間を検索一致が見つからない場合明示的に指定された名前空間のすべての検索が完了した後、\*最も内側のコンストラクトの外側へから DefineInNameSpace コンストラクトします。 「名前なし」の名前空間を検索しようとそれが参照を解決するのにはその検索に失敗した場合とします。

**注**  すべての参照を解決するために必要な名前空間を使用して指定する外部の影響から名前空間の検索順序を隔離する必要がある場合\*UsingNameSpace を構築します。

 

依存しないようにして、\*ホストは追加のインクルード ファイルを囲む場合がありますので、検索順序を確立するために DefineInNameSpace コンストラクト\*UsingNameSpace を構築し、ホストが指定した名前空間が検索されますによって指定された名前空間の前に、 \*DefineInNameSpace を構築します。

たとえば、されたテンプレートには、以前は 2 つの名前空間テンプレート名の解決に使用する明示的に指定されているが定義されています。 によって指定される任意の名前空間\*UsingNameSpace する必要があります以前によって定義されている\*DefineInNameSpace します。 これが存在し、NULL の記号での名前は常に"名前のない"名前空間は例外です。

次のコード例では、検索順序を定義する「名前なし」の名前空間を指定する方法を示します。

```cpp
*UsingNameSpace: NSName2
{
    *UsingNameSpace:  *%%%%%  omitting symbol specifies the  Unnamed 
*%  Namespace.
    {
        *UsingNameSpace: NSName
        {
            *Template:  ANOTHER_TEMPLATE
            {
                *Inherits: TEMPNAME
            }
        }
    }
}
```

前の例では、「名前なし」の名前空間を明示的に指定した名前空間のすべての検索が失敗したが、例では、NSName2 名前空間の前に、「名前なし」の名前空間を検索することを明示的に指定した後に検索されます。

GDL データ エントリ、テンプレート名の使用を明示的に参照するため\*UsingNameSpace はテンプレートがデータの各エントリに割り当てられている影響しません。 ただし、名前空間検索を注文する\*UsingNameSpace を指定します (これは有効では、最初の GDL データ エントリの解析時に) ルート テンプレートの検索を使用します。 1 つまたは複数の GDL ヘッダー ファイルを含める場合は、最初にデータのエントリを定義し、したがって名前空間がルート テンプレートを検索するために使用を決定するを誤ってにはなりませんことを確認する必要があります。

**注**  マクロ定義のスコープ制限は、外側の入れ子のレベルでします。 ただし、名前空間の入れ子のレベルは、マクロのスコープがその名前空間の外部で表示されるのに十分な大きさでない場合は、特定の名前空間に属しているマクロを定義する必要はありませんのでにマクロ定義のスコープを制限されません。

 

Namespace コンストラクトは、他の種類の構成要素の間でインタリーブできます。 これは、名前空間のコンス トラクターが表示される場所に制限はほとんどありません。 名前空間の非構造は、名前空間の解決には影響しません。

 

 




