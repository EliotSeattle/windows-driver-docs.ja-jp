---
title: DirectX の圧縮 VolumeTexture 形式
description: DirectX の圧縮 VolumeTexture 形式
ms.assetid: 5a655a30-e489-4691-873a-58bece059877
keywords:
- テクスチャ形式のボリュームを圧縮する圧縮テクスチャ WDK DirectDraw を描画するには、
- 圧縮されたテクスチャ WDK Windows 2000 を表示、DirectDraw 圧縮テクスチャ形式のボリューム
- 圧縮されたテクスチャ サーフェス WDK DirectDraw、ボリュームの圧縮テクスチャ形式
- WDK DirectDraw、圧縮されたテクスチャを表示します。
- 圧縮テクスチャ WDK DirectDraw、
- DXVN WDK DirectDraw
- DXTN WDK DirectDraw
- WDK DirectDraw をスライス
- ボリューム テクスチャ WDK DirectDraw
- WDK DirectDraw 帯域幅消費型の表示
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: b2f614b4fcf6e1d9b2c5af158553897881feae94
ms.sourcegitcommit: a33b7978e22d5bb9f65ca7056f955319049a2e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/31/2019
ms.locfileid: "56571667"
---
# <a name="directx-compressed-volumetexture-formats"></a>DirectX の圧縮 VolumeTexture 形式


## <span id="ddk_directx_compressed_volumetexture_formats_gg"></span><span id="DDK_DIRECTX_COMPRESSED_VOLUMETEXTURE_FORMATS_GG"></span>


ボリュームのテクスチャ マップは、領域の 3D true 領域を通じて定期的に生成されたデジタル化されたイメージです。 たとえば、火の球をサンプリングすることがあり、スライス内の炎を模した「金額」を考慮します。 この意味では、炎を模したの量は、イメージ内の各ピクセルのアルファ、赤、緑、青のコンポーネントの値のセットを表します。 全体の炎を模したは、一連のこれらのスライスによって表されます。

DirectX のボリュームのレンダリングの詳細に進んでがいくつかの用語を明確に重要です。 ボリュームのデータ セットを表すコンピューター グラフィックスで使用される 2 つの一般的な方法はあります。 それぞれの場所にイメージをサンプリングし、適切な ARGB 値を格納する 1 つです。 たとえば、炎を模したのデータは、256 の 3 次元配列 X 256 X 256 として保存でした。 これには、約 64 MB、配列内の各場所で 32 ビット値を格納する必要があります。 (医療の画像など、一部のアプリケーションは、この量のデータを必要があります)ただし、4 または 8 スラブに炎を模した「スライシング」は、非常に良好な近似を作成できます。 各スラブ 256 x 256 要素、各要素を表しますスラブ内のデータの領域を格納します。

サイズ 256 X 256 X 4 の配列であると想定していますし、各場所で 32 ビット値を格納するストレージ (データが圧縮されている場合以下) の 1 MB のみが必要です。 これら 2 つの方法について説明する理由をされているものをそれぞれの場所に格納されているデータ値は異なる、非表示にするのには炎を模したの背後にあるイメージにする場合。 データ セットを 256 X 256 X 256 の完全な要素のいずれかは約 1/256 の最終的なアルファと色を投稿可能性があります。 スライスのメソッドで要素はでした最大最終的なアルファとそのピクセルを使用する色の 0 から任意の場所投稿します。 問題は、サンプリングの両方の種類を記述することがあります"voxel"という用語を使用します。 DirectX 8 以降、スライスのメソッド (「ボリューム テクスチャ リング」と呼ばれる多くの場合) は、サポートされている唯一の方法です。 考え方としては妥当なサイズのボリュームのデータ セットを削減します。 テクスチャのハードウェアを少し変更を加える、DirectX のグラフィックス API は高パフォーマンスなレンダリング帯域幅消費型を公開できます。

これまで、このセクションの大部分に重点を置いて DXT*N*サーフェスの形式に圧縮します。 これらの形式は、2 D テクスチャに対しても機能します。 これらではありません、ただしにアクセスする追加のハードウェアのサイクルが必要なサーフェスを別のボリュームのデータ セットが格納されているために、ボリューム データのセットを使用しているときに。 この問題を解決するには、DirectX の 8 には、画面形式のボリュームのセットがサポートしています。

考え方は、ボリュームのスライスを受け取り、それらを圧縮する DXT を使用して*N*します。 その後、メモリ、DXT に順番に完了したサーフェスを格納する代わりに*N*データ ブロックが再度並べ替えられます。 並べ替えは、小規模の 4 X 4 テクセルがフォーム データ キューブをブロックするために行われます。 4 X 4 X 1、4 X 4 行 2、4 X 4 X 3 または 4 X 4 X 4 できます。 1 順序 X 4 X 4 が DXT1 DXT5 経由で使用すると同じであることに注意してください。 重要な点は次のとおりです。

ボリュームのサーフェスは DXT で圧縮されているデータのスライス*N*とデータの 3D の局所性のアカウントに並べ替えられます。 これらの並べ替えられたデータ構造、Fourcc の DXV1、…、DXV5 によって参照される (またはだけ DXV*N*に一般的なケースについて説明します)。 DXV1 データ構造体は、並べ替えられた DXT1 サーフェスのセットを保持 DXT2 のサーフェスのセットを保持 DXV2 ことに注意してください。

### <a name="span-iddxvndetailsspanspan-iddxvndetailsspandxvn-details"></a><span id="dxvn_details"></span><span id="DXVN_DETAILS"></span>DXV*N*の詳細

DXV*N* 1 ディープ配置に格納されている画面には、4 x 4 DXT の 1 つのセットが含まれています。*N*サブブロック (DXT だけが有効な*N*画面)。 DXV*N* 4 x 4 x 2 ブロック形式の構造体には、2 つの 4 x 4 DXT が含まれています。*N* subblocks、1 つの隣接する 2 つのデータ スライスの各から取得されます。 このメソッドは、DXV を使用して*N* 4 x 4 x 4 ブロック形式の構造体には、次の 4 つの 4 x 4 DXT が含まれています。*N*サブブロックを 4 つのデータ スライスから取得されます。 すべてのケースで、 *N* DXV で*N*対応する DXT と照合するために使用*N*使用される圧縮の種類。 DXT*N*ブロックは、64 ビット (色と 1 ビットのアルファ、または 128 ビット追加アルファ情報を含む) として保存できます。 したがって、DXV*N*サブブロックの種類に基づいて、同じ考えられるサイズである*N*します。DXT1 と DXV1 が DXT2、中に、64 ビットのサブブロックを使用して、..、DXT5 と DXV2、..、DXV5 128 ビットのサブブロックを使用します。

テクセルの座標を指定された *(u、v、p)* 場所*u* {0, 1、…、*幅*-1}、 *v* {0, 1,...,*高さ*-1}、および*p* {0, 1,...,*深さ*-1}、圧縮されたブロックとサブブロックそのテクセルを格納しているメモリ内の対応するアドレスを計算する、次を使用できます。 既存の DXT が subblock 形式に一致する前述のように、*N*形式。

```cpp
subblock_size = 8 (for DXT1)
subblock_size = 16 (for DXT2,...,DXT5)
block_size = MIN(p, 4) * subblock_size
horiz_stride = (width + 3) >> 2
planar_stride = ( (height + 3) >> 2) * horiz_stride
block_byte_address = block_size *
    ( (p >> 2) * planar_stride + (v >> 2) * horiz_stride + (u >> 2) )
subblock_byte_address = block_byte_address + ((p & 3) * subblock_size)
```

 

 





