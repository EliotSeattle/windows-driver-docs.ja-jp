---
title: タイル リソース
description: タイルリソースの場合、デバイスページングキューで実行されている非同期ビデオメモリマネージャーサービスでは十分ではありません。
ms.assetid: D48D2046-64A6-4B0E-9235-84DD2A83DB39
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 8dafc558d169666d2bdec0903a874af3e06f0d37
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72825498"
---
# <a name="tile-resources"></a>タイル リソース


タイルリソースの場合、デバイスページングキューで実行されている非同期ビデオメモリマネージャーサービスでは十分ではありません。 特に、タイルリソースの場合は、レンダリングと共にページテーブルの更新をキューに配置し、描画操作間で更新が同期的に適用されるようにします。

たとえば、アプリケーションによって次の API 呼び出しシーケンスが指定されたとします。

1.  描画 \#42
2.  タイルマッピングの更新
3.  描画 \#43

新しい状態のページテーブルで*描画 \#43*が実行されている間、*描画 \#42*が古い状態のページテーブルで実行されるようにしたいと考えています。 上書きなしフラグを指定する*更新タイルマッピング*操作の場合、この同期は少ししかできませんが、高パフォーマンスの同期更新をサポートする必要があります。
ハイパフォーマンスキュー更新をサポートするには、ページング操作を事前に生成してコンテキストにキューに配置し、依存表示コンテキストが特定のポイントに到達した後に実行されるのを待機する必要があります (例: 描画 \#42)。

つまり、ページング操作は、特定のレンダリングコンテキストによって通知されるグラフィックス処理ユニット (GPU) の待機の背後でキューに入れる必要があります。 このため、共有システムコンテキストに直接キューを設定することはできません。これは、あるアプリケーションがシステム内の他のすべてのユーザーに対してページング操作の実行をブロックする可能性があるためです。

理論的には、今日のパケットベースのスケジュールでは、操作の待機部分をデバイスページングキューに実装することで、待機状態を監視し、待機条件が満たされた後で、ページング操作を共有システムコンテキストに送信できます。 ただし、パケットベースのスケジュールを超えてハードウェアのスケジュールを設定するため、最大限のパフォーマンスを得るために、GPU を使用してインタロックされた操作を GPU 同期プリミティブにすることをお勧めします。

この問題を解決するために、コンテキストごとのページングに付随するコンテキストの概念を紹介します。 ページングコンパニオンコンテキストは、 [*Updat/Puvirtualaddress*](https://docs.microsoft.com/windows-hardware/drivers/ddi/d3dumddi/nc-d3dumddi-pfnd3dddi_updategpuvirtualaddresscb)への最初の呼び出し時に遅延作成され、インタロックされた同期を必要とするすべてのページテーブルの更新に使用されます。 *Updat・ Pupuvirtualaddress*は、GPU で監視されているフェンスオブジェクトと特定のフェンス値をパラメーターとして受け取ります。 コンパニオンコンテキストは、この監視対象のフェンスを待機してページテーブルを更新し、監視対象フェンスオブジェクトをインクリメントして、それを通知します。 これにより、レンダリングコンテキストがコンパニオンコンテキストと緊密に同期されます。

次に、コンパニオンのコンテキストを使用したページテーブルの更新を示します。

![インタロックページテーブルの更新](images/tile-resources.1.png)

このコンパニオンコンテキストは、コンテキストの作成時にカーネルモードドライバーによって選択されたエンジンに対してビデオメモリマネージャーによって遅延的に作成され**ます (Dxgkarg\_CREATECONTEXT。PagingCompanionNodeId**)。

コンパニオンコンテキストは、プロセスごとの特権のあるアドレス空間で実行されます。 アドレス空間は、カーネルによって制御され、カーネルで生成されたダイレクトメモリアクセス (DMA) バッファーのみで実行が許可されるため、特権が与えられます。 それ以外の場合は、これは通常の GPU 仮想アドレス空間であり、特別なハードウェア仮想アドレス空間の特権のサポートは必要ありません。

わかりやすくするために、システムのページングプロセス GPU 仮想アドレス空間を再利用するのではなく、プロセスごとの特権を持つ GPU 仮想アドレス空間を選択しています。 タイルリソースのマッピングとマップ解除が一般的であることがわかった場合は、アプリケーションページテーブルをアドレス空間に完全にマップして、頻繁にマップ/マッピング解除しないようにする必要があります。 また、後で詳しく説明するように、すべてのタイルプールを永続的な方法でマップする必要もあります。 システムアドレス空間でこれらの永続的なマッピングを行うと、不要な複雑さが発生します。

プロセスごとの特権を持つ GPU 仮想アドレス空間が初期化されます。これにより、プロセス GPU ページテーブルがアドレス空間を通じて表示されるようになり、update コマンドで GPU を使用してさまざまなページテーブルエントリを更新できるようになります。 さらに、プロセスによって作成されたすべてのタイルプールもアドレス空間にマップされます。

コンパニオンコンテキストによってページテーブルエントリが更新される方法は少し特殊で、いくつかの説明が必要です。 共有システムコンテキストでの実行のために*マップ*操作がキューに置かれている場合、ビデオメモリマネージャーは、マップされている物理アドレスを認識し、それらの物理アドレスは関連するページングバッファーに直接表示されます。 この場合、 [*Updatepagetable*](https://docs.microsoft.com/windows-hardware/drivers/display/dxgkddiupdatepagetable)ページング操作が使用されます。ビデオメモリマネージャーでは、特定のページに対するページング操作が、他の目的で再利用される前に完了することを保証します。

ただし、関連するコンテキストでのページテーブルの同期更新では、処理が困難になります。 ビデオメモリマネージャーは、更新操作の作成時に参照されるタイルプールの物理ページを認識しています。ただし、これらの操作は、任意の長時間の GPU 待機 (アプリでデッドロックが発生し、シグナルが発生しない可能性があります) の背後でキューに入れられます。マネージャーは、ページング操作が実際に実行されるときにタイルプールの物理ページがどのようになるかを認識しません。また、ビデオメモリマネージャーは、その場所のタイルプールを任意の長い時間にわたって保持することはできません。

この問題を解決するには、基本的に、ページング操作をキューに入れ、後で物理アドレスが変更されたときにパッチを適用する必要があります。または、更新で使用される実際のアドレスを遅延バインドする必要があります。ビデオメモリマネージャーは後者を実行します。

この問題を解決するには、ビデオメモリマネージャーで2つの処理を行います。 まず、GPU 仮想アドレスを、プロセスの特権を持つアドレス空間内のプロセスに属するすべてのタイルプール要素にマップします。 タイルプールがメモリ内を移動すると、ビデオメモリマネージャーは、他の割り当ての種類と同じ単純なメカニズムを使用して、タイルプールの正しい場所を指す GPU 仮想アドレスを自動的に維持します。

タイルリソースページのテーブルエントリを更新するために、ビデオメモリマネージャーに新しい**CopyPageTableEntry**ページング操作が導入されました。これにより、ページテーブルエントリがタイルプール仮想アドレスからタイルリソース仮想アドレスにコピーされます。 タイルプールがメモリ内を移動すると、ビデオメモリマネージャーはタイルプールの仮想アドレスを最新の状態に保ちます。そのため、コピー操作の実行時間は、タイルプールの現在有効な物理的な場所であることが保証されます。生成されたコマンドと、実際に実行しているコマンド。

特定のタイルプールを参照しているキューに登録されたページテーブルの更新がある限り、ビデオメモリマネージャーは、ユーザーモードドライバーまたはアプリケーションが示す内容に関係なく、そのタイルプールをアプリケーションの常駐要件に保持します。タイルプールの仮想アドレスは、更新操作を実行するときに有効です。

このメカニズムを次に示します。

![ページテーブルのコピー操作](images/tile-resources.2.png)**

## <a name="span-id_update_gpu_virtual_address_on_gpus_with_cpu_virtual_page_table_update_modespanspan-id_update_gpu_virtual_address_on_gpus_with_cpu_virtual_page_table_update_modespanspan-id_update_gpu_virtual_address_on_gpus_with_cpu_virtual_page_table_update_modespan-update-gpu-virtual-address-on-gpus-with-cpu_virtual-page-table-update-mode"></a><span id="_Update_GPU_virtual_address_on_GPUs_with_CPU_VIRTUAL_page_table_update_mode"></span><span id="_update_gpu_virtual_address_on_gpus_with_cpu_virtual_page_table_update_mode"></span><span id="_UPDATE_GPU_VIRTUAL_ADDRESS_ON_GPUS_WITH_CPU_VIRTUAL_PAGE_TABLE_UPDATE_MODE"></span>CPU\_仮想ページテーブル更新モードで GPU の GPU 仮想アドレスを更新する


**DXGK\_PAGETABLEUPDATE\_CPU\_仮想**ページテーブル更新モードをサポートする gpu では、 **CopyPageTableEntries**操作は使用されません。 これらは、ページングバッファーを使用しない統合 GPU です。 ビデオメモリマネージャーは、更新操作を適切な時間まで延期し、 [*Updatepagetable*](https://docs.microsoft.com/windows-hardware/drivers/display/dxgkddiupdatepagetable)操作を使用してページテーブルを設定します。

この方法の欠点は、 [*Updatepagetable*](https://docs.microsoft.com/windows-hardware/drivers/display/dxgkddiupdatepagetable)操作がレンダリング操作と並行していないことです。 この利点は、ドライバーがページングバッファーのサポートを実装する必要がなく、即時操作として*Updatepagetable*を実装する必要がないことです。

 

 





