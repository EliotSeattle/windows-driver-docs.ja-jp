---
title: バンク フレーム バッファーのサポート
description: バンク フレーム バッファーのサポート
ms.assetid: edb0421b-fd1d-43da-9c1f-3414182282fb
keywords:
- ディスプレイ ドライバー WDK Windows 2000、バンク フレーム バッファー
- バンク フレーム バッファー WDK Windows 2000 の表示
- フレーム バッファー WDK Windows 2000 を表示します。
- メモリ バンク WDK Windows 2000 を表示します。
- バンク コールバック WDK Windows 2000 を表示します。
- 銀行 WDK Windows 2000 を表示します。
- バンク フレーム バッファーへのビデオ メモリのマッピング
- 複数の銀行のまたがりメモリ割り当てください。
- フレーム バッファー WDK Windows 2000 で、銀行を複数の表示します。
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: c736ca73d6764e574de3269cc8c0ce57b994481f
ms.sourcegitcommit: fb7d95c7a5d47860918cd3602efdd33b69dcf2da
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/25/2019
ms.locfileid: "67374390"
---
# <a name="supporting-banked-frame-buffers"></a>バンク フレーム バッファーのサポート


## <span id="ddk_supporting_banked_frame_buffers_gg"></span><span id="DDK_SUPPORTING_BANKED_FRAME_BUFFERS_GG"></span>


今日のアクセラレータのほとんどが*フレーム バッファー*アドレス空間の CPU に直線的にマップできます。 このようなデバイスのディスプレイ ドライバーをバンク フレーム バッファーをサポートする必要はありません。

GDI に直接アクセスできない*メモリに蓄積される*バンク フレーム バッファーに関連付けられています。 その結果、このようなフレーム バッファーを使用したデバイスのディスプレイ ドライバーでは、一連の連続した銀行にフレーム バッファーを分割して GDI 適切なフレーム バッファーの銀行への描画操作を実行するための手段を提供する必要があります。 呼ばれるメカニズムを使って描画操作を完了する、必要に応じて、後続の銀行に移動して、フレーム バッファーの 1 つの銀行にデータを書き込む GDI が行われた、*コールバックが蓄積される*します。

*Permedia*サンプル表示出荷ドライバーをドライバー開発キット (DDK) でバンク フレーム バッファー サポートの実装のサンプル コードを提供します。

**注**   3 dlabs permedia2 チップが、Microsoft Windows Driver Kit (WDK) に含まれていない (*3dlabs.htm*) と 3 dlabs Permedia3 (*Perm3.htm*) ディスプレイ ドライバーのサンプルです。 これらのサンプル ドライバーは、DDK - WDHC web サイトの Windows ドライバー開発キットのページからダウンロードできる Windows Server 2003 SP1 DDK から取得できます。

 

次の図は、サンプル アクセラレータをフレーム バッファー、1024 x 768-- VGA はバッファーをいくつかの銀行に分かれていますを表示します。 この図は、例示のみを目的のために提供されます。 ディスプレイ ドライバーは、物理アドレス A000 ない具体的には使用しませんが、ミニポート ドライバーによって渡された論理アドレスを使用します。

![バンク フレーム バッファーへのビデオ メモリのマッピングを示す図](images/banking1.png)

この例では、ビデオ メモリの内容は、一連の連続した銀行のフレーム バッファーに対応する描画操作を通じて、アクセラレータに書き込まれます。 GDI に関する限り、各描画操作の標準的なフレーム バッファーとアクセラレータのフレーム バッファーの別の銀行にできるように表示されます。 アクセラレータのデバイス ドライバーは、銀行の銀行によってごとに、アクセラレータのフレーム バッファーに描画するために、GDI が銀行業務を処理します。

フレーム バッファーが、*画面のデバイスで管理された*アクセラレータはバンク フレーム バッファーを使用すると、ディスプレイ ドライバー描画関数の呼び出しをフックするためです。 ディスプレイ ドライバー フックの描画パス、パスの塗りつぶしなどの呼び出し時または*ビット ブロック転送*、フレーム バッファーでは、どの銀行が呼び出された描画関数によって影響を受けるを決定します。

ドライバー呼び出し、適切な場合、GDI 描画機能を実行することにした場合、ドライバー、**への Eng * * * Xxx*関数。 ただし、呼び出しを行う前に、ディスプレイ ドライバーする必要がありますかぎ状の呼び出しで受け取ったクリップと画面のオブジェクトを変更して、コールバックで GDI にこれらの変更されたオブジェクトを渡します。 クリップと画面のオブジェクトは、GDI 描画範囲の銀行に防ぐために変更されます。 つまり、GDI が [次へ] の銀行で部分的に存在するパスを描画するために呼び出された場合、およびクリップと画面のオブジェクトの変更がない場合は、GDI は現在の銀行のエクステントを超えるメモリに書き込みます。 GDI は、銀行の範囲外に描画するためにしようとすると、結果として得られるアクセス違反を追跡しにくくなりますできます。

次の図の例のバンク フレーム バッファーを示します、画面に描画される楕円のオブジェクトがバンク フレーム バッファー、銀行の 2 つの銀行にまたがる\_1 と銀行口座\_2。

![フレーム バッファー内の複数の銀行にまたがる描画オブジェクトを示す図](images/pvscan0.png)

このオブジェクトを描画する GDI する必要がありますまず描画楕円の上の部分 (銀行で\_1)、標準的なフレーム バッファーと同じ標準バッファーに、描画、楕円の下の部分にします。 ディスプレイ ドライバーは、銀行に GDI によってこれら 2 つの連続する書き込みをマップし、必要があります\_1 と銀行口座\_バンク フレーム バッファーを表示し、各銀行の制限を超える書き込みが GDI をようにの 2。

バンク フレーム バッファー処理を実行する場合、ディスプレイ ドライバーは、呼び出しのパラメーターをチェックして、または GDI を呼び出すことで (先の四角形のサイズ) のオブジェクトの境界を判断できます。 オブジェクトの境界から、オブジェクト数の銀行がまたがるドライバーを確認できます。 外接する四角形があるすべての銀行は、適切な GDI にディスプレイ ドライバーの呼び出しは、呼び出しごとに値を変更する関数を描画します。

ドライバーの変更、 [ **CLIPOBJ** ](https://docs.microsoft.com/windows/desktop/api/winddi/ns-winddi-_clipobj)銀行の境界内の変更に対応する GDI によって最初のメンバーに渡されました。 上端と下端のスキャンの値は、GDI が銀行の制限を超えて描画しないように再定義されます。 Bank のマネージャーは、GDI から取得した元の CLIPOBJ データを取得し、後で復元値を保持します。 新しいを提供する境界を変更し、 **rclBounds.top**と**rclBounds.bottom**に描画されている銀行の程度を記述する値。 銀行、中には、GDI がクリッピング パス全体を描画し、現在の銀行の制限を上書きしないようにサイズを実行する必要があります。

GDI によって渡された元の CLIPOBJ として定義された場合、 **NULL**または DC\_単純、ディスプレイ ドライバー渡しますを使って作成された代替 CLIPOBJ、 **EngCreateClip** GDI がクリップするように、1 つの銀行のエクステント。 ディスプレイ ドライバーと複雑な CLIPOBJ を変更、CLIPOBJ が楕円の上の図に示すように三角形クリップ オブジェクトなどの複雑な場合、 **rclBounds.top**と**rclBounds.bottom**クリップを 2 つのオブジェクト間の付加的な効果を生成する値。 その結果、GDI は、銀行の最後に書き込みできません。 ドライバーでは、GDI から取得した CLIPOBJ データの元の境界も復元する必要があります。

ディスプレイ ドライバーが、OC を設定するだけでなく、境界値を変更するには、\_銀行\_クリップ フラグで、**オブジェクト * * * をクリップします。*

GDI を参照するよう、標準的なフレーム バッファーの先頭の描画にも反映される必要があります。 GDI を含むの SURFOBJ にポインターを単に取得描画するために呼び出されると、 **pvScan0**、 **lDelta**、および**iBitmapFormat**メンバー。 GDI は、次のようにこれらの値を使用して、画面に描画する場所を計算します。

```cpp
start_draw_point = pvScan0 + (y*lDelta) + (x*PixelSize(iBitmapFormat))
```

場所*x*と*y*描画が開始される座標と*開始\_描画\_ポイント*先のアドレスは、最初のアドレスピクセルが描画されます。 GDI 描画呼び出しごとにこの計算を実行しての SURFOBJ は常に参照**pvScan0**、標準的なフレーム バッファーの先頭の論理アドレスであります。

論理アドレスからの GDI では、8 ビット ピクセルあたり 64 K のフレーム バッファーの内容全体を描画する必要がある場合の開始など**pvScan0** = 0x100000、0x10FFFF の描画操作になります (0x100000 + (63\*1024) + (1023))、場所*y* 63、 **lDelta** 1024 と*x*は 1023 (最後のスキャン ライン内の最後のピクセルの位置)。

ディスプレイ ドライバー オブジェクトの部分を描画するために、GDI の呼び出し内にある [次へ] の時間、*次*バンク フレーム バッファー、GDI の銀行の値を解釈する*y* 64 として。 0x100000 の値を持つ**pvScan0** 64 ビット*y*、GDI は 0x110000 でデータの書き込みを開始しようとしています。 ただし、0x110000 は 64 K のフレーム バッファーの 0x10FFFF の範囲外ですしする必要がありますに書き込まれません GDI でこの操作中にします。

その結果、ディスプレイ ドライバーは、GDI がフレーム バッファーの 2 回目以降の銀行で表示されるデータの書き込みを要求するときに、ドライバーする必要があります値をデクリメントの**pvScan0** GDI を計算するため、あるポイントを開始0x100000 の例のアドレスをまだ参照されています。 続行すると、例では、つまり、デクリメントの値**pvScan0** 0x090000 フレーム バッファーの 2 つ目の銀行に描画するときの値にします。 この変更を結果として**pvScan0**GDI が 0x100000 のアドレスへの参照を使用して描画します。 つまり 0x090000 + (64\*1024) + 0 は 0x100000、等しく GDI がフレーム バッファーの 2 つ目の銀行にマップされるデータの順序で描画するために始める必要があります。

 

 





