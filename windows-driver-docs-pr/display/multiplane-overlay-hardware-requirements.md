---
title: マルチプレーン オーバーレイのハードウェア要件
ms.assetid: 3BDA8F54-A0D8-4879-A828-89A2E4254179
description: Multiplane オーバーレイをサポートするために必要なハードウェア要件。
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 1bff654fda8156c47104c795d5aa410667ec12be
ms.sourcegitcommit: a33b7978e22d5bb9f65ca7056f955319049a2e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/31/2019
ms.locfileid: "56573326"
---
# <a name="multiplane-overlay-hardware-requirements"></a>マルチプレーン オーバーレイのハードウェア要件


Multiplane オーバーレイをサポートするためには、ディスプレイ ドライバーとハードウェアは必要はありません。 ただし、multiplane オーバーレイのサポートを提供するハードウェアは、これらの要件を満たす必要があります。

-   ハードウェアは、重複しない平面をサポートする必要があります。
    -   別の平面は画面の一部を別の相互に排他的に対応中に、1 つの平面は、画面の 1 つの部分に対応できます。
    -   平面は、画面の任意の部分は含まれていない、その領域のブラック アウト ハードウェアがスキャンする必要があります。 ハードウェアでは、最下位に仮想の平面があると想定できます*z*黒色で塗りつぶされている順序。
-   ハードウェアは、重複する平面をサポートする必要があります。
    -   ハードウェアは、有効または平面あたりごとにアルファ ブレンドを無効にできる必要があります。 (アルファ ブレンドは、手法、ソース ビットマップの色と組み合わせて使用する新しいコピー先ビットマップを生成するために、コピー先ビットマップに)。
    -   前乗算されたアルファを使用してプレーンな組み合わせをサポートする必要があります。
-   出力ターゲットの 1 つのみがアクティブである場合、active の出力は multiplane オーバーレイをサポートする必要があります。 場合は、複数の出力は、同時にアクティブなは、複製モードは、ハードウェアを報告しないすべてのアクティブな出力 multiplane オーバーレイをサポートする場合を除き、multiplane オーバーレイをサポートしていること。
-   デスクトップ ウィンドウ マネージャー (DWM) のスワップ (プレーン 0) は、その他のオーバーレイ平面との対話できる必要があります。
-   すべての平面は、有効または無効になっている、平面 0 (DWM のスワップ) を含むできる必要があります。
-   ソースおよび変換先のクリッピング、平面 0 (DWM のスワップ) を含む、すべての平面をサポートする必要があります。
-   圧縮し、ストレッチが有効になっている他の面から独立して、少なくとも 1 つの平面をサポートする必要があります。
-   Scaling をサポートする平面には、バイリニア両方のフィルター処理およびバイリニアよりも高い品質をフィルター処理をサポートする必要があります。
-   少なくとも 1 つの平面がこれら YUV 形式をサポートする必要があります (詳細については、次を参照してください。 [YUV 形式の範囲の Windows 8.1 で](yuv-format-ranges.md))。
    -   ITU BT.601 と BT.709 YUV RGB 行列の YUV 形式への変換からの両方。
    -   通常 (または studio) の範囲 YUV 輝度 (16 235) と拡張範囲 YUV 輝度 (0 - 255)。
-   ハードウェアは、これらの登録シナリオのラッチを処理する必要があります。
    -   (バッファーのアドレス、クリッピング、スケーリング、およびなど) のすべての面で属性は、垂直帰線期間中に投稿アトミックにする必要があります。 アトミックにすべての post する必要がありますレジスタのブロックを更新する場合、たとえば、オーバーレイ平面に関連する 20 のレジスタの 10 を作成した後、垂直同期が発生した場合、いずれは投稿次の VSync まですべての投稿を現在の垂直同期できない場合があるため)。
    -   各プレーンは、その他の面から個別に更新できます。 たとえば、0 面レジスタが、垂直同期の前に更新され、1 プレーンの後で登録する場合は、垂直同期が発生すると、プレーン 1 更新プログラムが次の VSync まで待つ場合がありますが、時間で、0 面の更新プログラムを実行するに更新されます。
    -   複数の面が存在する 1 つの呼び出し中に更新されると、アトミックに更新が発生します。 たとえば、単一 present を呼び出す場合は、平面 0 かつ有効な間 1、平面 0 レジスタでは、1 プレーンを登録も同じの垂直同期の投稿されない限り、垂直同期に送信する必要がありますを更新はしません。
-   変換、拡大縮小、および描画の順序で発生する必要があります。
    1.  ソースの割り当てが指定したソースの四角形に従って切り取られます。 元の四角形にソース割り当てのサイズに制限することが保証されます。
    2.  縦方向の画像が要求された場合に反転し、イメージの水平方向の反転 を適用します。
    3.  適用先の四角形に応じてスケーリング、に従ってクリップ四角形の領域を適用し、スケーリングするときに、適切なフィルターを適用します。
    4.  その他のレイヤーでの割り当てとのブレンドします。 下に上から描画を実行する必要があります (または非透過のレイヤーがヒットするまで) で*z*-順序。 アルファ ブレンドが要求された場合、ごとのピクセルのアルファを受け付ける必要があるハードウェアと色の値が事前乗算アルファです。 次の擬似コードが、ソースを下に上から繰り返し先操作の実行にします (((レイヤー\[0\]レイヤーの上に\[1\]) レイヤーの上に\[2\])... レイヤー経由で\[n\])。 先の四角形の外部で各レイヤーは、透過的な (0,0,0,0) として扱う必要があります。

        ``` syntax
        Color = Color[0]; // Layer 0 is topmost.
        Alpha = Color[0].Alpha;
        for (i = 1; Alpha < 1 && i < LayersToBlend; i++)
        {
            Color += ((1 - Alpha) * Color[i]);
            Alpha += ((1 - Alpha) * Color[i].Alpha);
        }
        Output Color;
        ```

        ハードウェアは、出力結果は同じ場合に限り、ページのトップへ下から blend ことができます。 ここでは、次の blend アルゴリズムを使用する必要があります。

        ``` syntax
        Color = Color[LayersToBlend-1];  // Bottom-most layer
        Alpha = Color[LayersToBlend-1].Alpha;
        if (LayersToBlend > 1)
        {
            for (i = LayersToBlend - 2; Alpha < 1 && i >= 0; i--)
            {
                Color = Color[i] + ((1 - Color[i].Alpha) * Color;
                Alpha = Color[i].Alpha + (1 - Color[i].Alpha) * Alpha;
            }
        }
        Output Color;
        ```

    5.  黒の色を領域に表示される必要があります、任意のレイヤーからの変換先の四角形のいずれかでは取り上げません。 ハードウェアでは、あるレイヤーが存在概念仮想最下位黒、画面のサイズであると想定できます。

 

 





