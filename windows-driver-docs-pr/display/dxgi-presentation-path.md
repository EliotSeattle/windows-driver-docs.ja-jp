---
title: DXGI プレゼンテーション パス
description: DXGI プレゼンテーション パス
ms.assetid: 3519172d-261c-4b33-b1e7-c4abf33b15f3
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 03dac3226d65734723a6ab903ccea3de2b3b4537
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72839723"
---
# <a name="dxgi-presentation-path"></a>DXGI プレゼンテーション パス


DXGI は、"ただ動作する" プレゼンテーション方法をアプリケーションに提供します。 たとえば、アプリケーションでは、ウィンドウモードと全画面モードを切り替える特別な操作を実行する必要はありません。 このプレゼンテーション方法は、DXGI とユーザーモードの表示ドライバーが連携して、複数のサンプルのアンチエイリアシング (MSAA)、モニターのローテーション、バックとフロントバッファーのサイズと形式の違いに対するプレゼンテーションを保持しているために発生する可能性があります。と全画面表示モードを比較しています。 DXGI のもう1つの利点は、ディスプレイアダプターでは、"ステートレス" の DDI が提供されるため、MSAA と回転したサーフェイスをスキャンする機能が制限されていることです。 ステートレスな DDI では、アダプターのドライバーは、DDI 呼び出し間でデータを記録する必要はありません。

プレゼンテーションの基本的なタスクは、表示されているバックバッファーから、表示のためにプライマリ画面にデータを移動することです。 このタスクは、次のセクションで説明されているさまざまな状況で実行されます。

### <a name="span-idwindowed_mode_with_dwm_onspanspan-idwindowed_mode_with_dwm_onspanwindowed-mode-with-dwm-on"></a><span id="windowed_mode_with_dwm_on"></span><span id="WINDOWED_MODE_WITH_DWM_ON"></span>DWM がオンになっているウィンドウモード

デスクトップ Windows マネージャー (DWM) を使用したウィンドウモードの場合-DXGI は DWM と通信し、DXGI プロデューサーのレンダーターゲットである共有リソースと DWM のテクスチャのビューを開きます。 この共有リソースは、アプリケーションによって作成されるバックバッファーに加えて存在します。 DXGI は、ドライバーの[**Bltdxgi**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)関数を呼び出して、任意のバックバッファーから共有サーフェスにデータを移動します。 この操作には、stretch、カラー変換、および MSAA 解決が必要な場合があります。 ただし、この操作では、変換元と変換先のサブ四角形は必要ありません。 実際、これらのサブ四角形は*Bltdxgi*の呼び出しで表現することはできません。 このビットブロック転送 (bitblt) では、 *pBltData*パラメーターが指す[ **\_\_ARG\_DDI**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_arg_blt)の**Flags**メンバーで、**現在**のフラグが常に設定されています。 **Present**フラグを設定すると、ドライバーは操作をアトミックに実行する必要があることを示します。 ドライバーは、DWM 操作をアトミックに実行して、DWM がコンポジションの共有リソースを読み取る間に、分裂の可能性を最小限に抑えます。

### <a name="span-idwindowed_mode_with_dwm_offspanspan-idwindowed_mode_with_dwm_offspanwindowed-mode-with-dwm-off"></a><span id="windowed_mode_with_dwm_off"></span><span id="WINDOWED_MODE_WITH_DWM_OFF"></span>DWM がオフになっているウィンドウモード

DWM を使用したウィンドウモードでは、dxgi はドライバーの present[**関数を**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)呼び出します。**このフラグは**、dxgi の FLAGS メンバー ( [ **\_DDI\_\_ARG**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_arg_present)の**Flags**メンバーに設定されています。パラメーターがを指しています。 この現在の*dxgi*の呼び出しでは、dxgi で、アプリケーションによって作成されたバックバッファーのいずれかを、 **HSurfaceToPresent**と**srcsubresourceindex**の DXGI\_DDI\_ARG\_存在するように指定できます。 追加の共有サーフェスはありません。

### <a name="span-idfull_screen_modespanspan-idfull_screen_modespanfull-screen-mode"></a><span id="full_screen_mode"></span><span id="FULL_SCREEN_MODE"></span>全画面表示モード

全画面表示のケースは、DWM がオンまたはオフになっているウィンドウモードよりも複雑です。

DXGI が全画面表示モードに切り替わると、帯域幅を削減し、垂直同期同期を取得するために、フリップ操作を悪用しようとします。 次の条件によって、フリップ演算が使用できなくなる可能性があります。

-   アプリケーションは、プライマリサーフェイスと一致するようにバックバッファーを再割り当てしませんでした。

-   ドライバーは、バックバッファーがスキャンされないことを指定しています (たとえば、バックバッファーがローテーションされているか、MSAA であるため)。

-   アプリケーションは、バックバッファーの内容を破棄し、チェーン内で1つのバッファー (合計) のみを要求した Direct3D ランタイムを受け入れることができないことを指定しました。 (この場合、DXGI では、バックサーフェスとプライマリサーフェイスが割り当てられます。ただし、DXGI では、 **Blt**フラグが設定されたドライバーの "存在する *" 関数が*使用されます)。

上記のいずれかの条件が発生すると、フリップ操作が妨げられ、 **Blt**フラグが設定されたドライバーの存在しない[**関数の呼び出し**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)も適切ではありません (バックバッファーがフロントバッファーと完全に一致しないため)。DXGI は*プロキシ画面*を割り当てます。 このプロキシ画面は、フロントバッファーと一致します。 そのため、プロキシ画面とフロントバッファーの間のフリップが可能になります。 プロキシサーフェイスが存在する場合、DXGI はドライバーの[**Bltdxgi**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)関数を**現在**のフラグがオフ (0) で使用して、アプリケーションのバックバッファーをプロキシ画面にコピーします。 この*Bltdxgi*呼び出しでは、DXGI が変換、拡大、および解決を要求する場合があります。 DXGI は、Dxgi の**Flags**メンバーに設定された**フリップ**フラグを使用してドライバーの*present*関数を呼び出します。 [ **\_DDI\_ARG\_現在**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_arg_present)の構造体を、スキャンアウトするためにプロキシ表面のビットを移動します。

ドライバーがスキャンから除外できることをユーザーモードの表示ドライバーに通知するために、ドライバーは、オプションの、およびオプションでないスキャンアウトサーフェイスのクラスに対して、リソース作成呼び出しを受け取ります。 オプションのスキャンアウトサーフェイスは、DXGI\_DDI\_プライマリ\_オプションのフラグによって指定されます。 オプション以外のスキャンアウトサーフェスには、DXGI\_DDI\_プライマリ\_オプションのフラグが設定されていません。 これらの種類のリソース作成呼び出しの詳細については、「[リソースの作成時に DXGI 情報を渡す](passing-dxgi-information-at-resource-creation-time.md)」を参照してください。

DXGI\_DDI\_プライマリ\_省略可能フラグを設定して、すべてのバックバッファーサーフェイス (つまり、オプションのサーフェス) を作成し、フロントバッファーまたはプロキシ画面 (つまり、非オプションのサーフェス) にフラグを設定しません。

バックバッファーに対して DXGI\_DDI\_プライマリ\_オプションが設定されている場合、ドライバーは\_SCANOUT フラグを\_せずに、DXGI\_DDI\_プライマリ\_ドライバー\_フラグを設定できます。 このフラグの設定の詳細については、「[リソースの作成時に DXGI 情報を渡す](passing-dxgi-information-at-resource-creation-time.md)」を参照してください。 ドライバーが DXGI\_DDI\_プライマリ\_ドライバー\_フラグを設定している場合、オプションのバッファーに対して\_はスキャンされません。これ以外に、DXGI が**Blt**フラグを使用してドライバーの存在し[**ない関数を**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)呼び出すことはありません。**フリップ**フラグが設定されたではなく、を設定します。

フロントバッファーまたはプロキシ画面に [DXGI\_DDI\_プライマリ\_省略可能] が設定されていない場合でも、ドライバーはリソース作成の呼び出しに失敗し、エラーコード DXGI\_DDI\_エラー\_サポートされていないため、スキャンアウトをオプトアウトできます。また、DXGI\_DDI\_プライマリ\_ドライバー\_フラグを設定すると\_\_はスキャンされません。

**   DXGI**を設定しないで作成呼び出しに失敗した場合は\_DDI\_プライマリ\_ドライバーの\_フラグ\_、メモリ不足などの実際のエラーケース用に予約されている\_はありません。

 

DXGI は、MSAA またはローテーションされたバッファーの全画面プレゼンテーションチェーンを作成しようとすると、このオプトアウト手法を悪用します。 ドライバーがこれらの種類のいずれかまたは両方をスキャンしない場合、ドライバーはオプトアウトします。次に、ドライバーがリソースの作成を受け入れるまで、DXGI は回転していない表面、MSAA 以外の画面、またはその両方を作成しようとします。 そのため、非オプションのサーフェスがフロントバッファーのフォーマット、サンプル数、ローテーション、およびサイズと完全に一致するまで、DXGI は徐々にフォールバックします。

ドライバーがオプション以外の画面から外れた場合でも、DXGI では、バックバッファーからプライマリサーフェイスにビットを移動する方法が必要になります。 このため、MSAA とローテーションのスキャンアウトをドライバーがオプトアウトした場合、ドライバーは、DXGI がドライバーの[**Bltdxgi**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)関数を呼び出すと、解決、回転、またはその両方を検出します。 ドライバーが終了すると、DXGI はプロキシ画面を作成し、 **Bltdxgi**を呼び出して、バックバッファーからそのプロキシ画面にデータを移動します。 プロキシがフロントバッファーと完全に一致するため、ドライバーはこのプロキシ画面をオプトアウトする理由がありません。

全画面表示モードに切り替えた後に、アプリケーションが画面を再作成しない場合は、次のような例外的な状況が発生します。

-   全画面表示モードになったときにアプリケーションが表面を再作成しない場合は、バッファーが形式、サイズ、回転、およびサンプル数と一致する場合でも、バッファーがフロントバッファーと一致しないと判断されます。 この決定の理由は、これらのバッファーが作成されたときに、オペレーティングシステムによって、特定のモニターにスキャンアウトするように、バックバッファーにタグ付けする必要があるためです。 全画面を入力するとモニターが動的に選択されるため、ウィンドウバックバッファーを特定のモニターに明確に割り当てることはできません。 そのため、DXGI は、これらのバックバッファーを (フリップ操作によって) スキャンアウトのためにドライバーに送信することはできません。 通常、この種類のアプリケーションは、DXGI を強制的にプロキシ画面を作成します。

-   ウィンドウモードに戻るときにアプリケーションがバックバッファーを再作成しない場合、DXGI はドライバーの[**Bltdxgi**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)を呼び[**出すか、または**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)( **Blt**セットを使用して) 使用して、以前にフリップ操作のために作成されたサーフェイス上で bitblt を実行する可能性があります。 この状況は問題ではありませんが、完全を期すためにここに記載されています。 アプリケーションがウィンドウモードに移行すると、DXGI は常にプロキシ画面を破棄することに注意してください。

また、アプリケーションが全画面表示モードの間は、アプリケーションがバッファーのサイズを動的に変更できることに注意してください。 この操作により、上記の状況で説明されているロジックが再び発生します。 そのため、プロキシ画面が作成され、破棄される可能性があります。アプリケーションが全画面表示モードのままであっても、時間の経過と共にオプトアウトが不要になることがあります。 また、全画面表示モードを終了せずに、出力を別のモニターに動的に転送することもできます。 そのため、アプリケーションのバックバッファーには別のモニターのタグが付けられているため、アプリケーションは、bitblt モードに切り替えます。

最後に、ドライバーで MSAA スキャンアウトがオプトアウトされない場合は、MSAA バックバッファーに関して発生する状況を認識しておく必要があります。このような状況では、ドライバーは MSAA のスキャンを行います。 そのため、DXGI は、フォールバック操作によって MSAA バックバッファーと MSAA フロントバッファーを交換し、デジタル-アナログコンバーター (DAC) に相当するものによって解決操作を実行します。 このような状況では、アプリケーションは全画面表示モードで、バッファーのサイズを動的に変更することができます。これにより、DXGI はドライバーの[**Bltdxgi**](https://docs.microsoft.com/windows-hardware/drivers/ddi/dxgiddi/ns-dxgiddi-dxgi_ddi_base_functions)関数の呼び出しに強制的に切り替わります。 バックバッファーとフロントバッファーの MSAA 特性は一致しているため、DXGI は、ドライバーが解決しない、場合によっては、カラー変換される可能性があるストレッチ bitblt を実行するように指定します。 ドライバーは、フロントバッファーへのマルチサンプルを解決せずにレプリケートする必要があります。これは、ドライバーが MSAA のスキャンを選択する場合に必要です。

 

 





