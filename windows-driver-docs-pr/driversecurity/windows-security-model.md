---
title: ドライバー開発者向けの Windows セキュリティ モデル
description: Windows セキュリティモデルは、主にオブジェクトごとの権限に基づいており、システム全体の特権はごく少数です。
ms.assetid: 3A7ECA7C-1FE6-4ADB-97A9-A61C6FCE9F04
ms.date: 02/01/2018
ms.localizationpriority: medium
ms.openlocfilehash: ce533aa2a2557b582d341a4737504bc6dfde85c1
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72829127"
---
# <a name="span-idintroductionspanspan-idintroductionspanspan-idintroductionspanwindows-security-model-for-driver-developers"></a><span id="Introduction"></span><span id="introduction"></span><span id="INTRODUCTION"></span>ドライバー開発者向けの Windows セキュリティモデル

Windows セキュリティモデルは、セキュリティ保護可能なオブジェクトに基づいています。 オペレーティングシステムの各コンポーネントは、役割を果たすオブジェクトのセキュリティを確保する必要があります。 そのため、ドライバーは、デバイスとデバイスオブジェクトのセキュリティを保護する必要があります。

このトピックでは、Windows セキュリティモデルがカーネルモードドライバーにどのように適用されるかをまとめます。 


## <a name="windows-security-model"></a>Windows セキュリティモデル

Windows セキュリティモデルは、主にオブジェクトごとの権限に基づいており、システム全体の特権はごく少数です。 セキュリティで保護できるオブジェクトには、プロセス、スレッド、イベント、およびその他の同期オブジェクトだけでなく、ファイル、ディレクトリ、およびデバイスに限定されません。

オブジェクトの種類ごとに、汎用の読み取り、書き込み、および実行の権限が、オブジェクト固有の詳細な権限にマップされます。 たとえば、ファイルとディレクトリの場合、使用可能な権限には、ファイルまたはディレクトリの読み取りまたは書き込みを行う権限、拡張ファイル属性の読み取りまたは書き込み権限、ディレクトリを走査する権限、オブジェクトのセキュリティ記述子を書き込む権限などがあります。 

セキュリティモデルには、次の概念が含まれます。

-   セキュリティ識別子 (Sid)
-   アクセストークン
-   セキュリティ記述子
-   Access Control リスト (Acl)
-   権限

### <a name="span-idsecurity_identifiers__sids_spanspan-idsecurity_identifiers__sids_spanspan-idsecurity_identifiers__sids_spansecurity-identifiers-sids"></a><span id="Security_Identifiers__SIDs_"></span><span id="security_identifiers__sids_"></span><span id="SECURITY_IDENTIFIERS__SIDS_"></span>セキュリティ識別子 (Sid)


セキュリティ識別子 (SID、*プリンシパル*とも呼ばれます) は、ユーザー、グループ、またはログオンセッションを識別します。 各ユーザーには一意の SID があり、ログオン時にオペレーティングシステムによって取得されます。

Sid は、オペレーティングシステムやドメインサーバーなどの機関によって発行されます。 一部の Sid は既知のものであり、識別子にも名前が付いています。 たとえば、SID S-1-1-0 は、Everyone (または World) を識別します。


### <a name="access-tokens"></a>アクセストークン

すべてのプロセスにはアクセストークンがあります。 アクセストークンには、プロセスの完全なセキュリティコンテキストが記述されています。 これには、ユーザーの SID、ユーザーが所属するグループの SID、ログオンセッションの SID、およびユーザーに付与されたシステム全体の特権の一覧が含まれます。

既定では、プロセスのスレッドがセキュリティ保護可能なオブジェクトと対話するときに、プロセスのプライマリアクセストークンが使用されます。 ただし、スレッドはクライアントアカウントの権限を借用できます。 スレッドが偽装されると、そのスレッドには、自身のプライマリトークンに加えて、偽装トークンが含まれます。 偽装トークンは、スレッドが偽装しているユーザーアカウントのセキュリティコンテキストを記述します。 偽装は、リモートプロシージャコール (RPC) 処理で特に一般的です。

スレッドまたはプロセスの制限されたセキュリティコンテキストを記述するアクセストークンは、制限付きトークンと呼ばれます。 *制限付きトークン*の sid は、セキュリティ保護可能なオブジェクトへのアクセスを許可するのではなく、アクセスを拒否するためにのみ設定できます。 また、トークンは、システム全体の特権の限られたセットを記述できます。 ユーザーの SID と id は変わりませんが、プロセスが制限付きトークンを使用している間はユーザーのアクセス権が制限されます。 [CreateRestrictedToken](https://docs.microsoft.com/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createrestrictedtoken)関数は、制限付きトークンを作成します。


### <a name="security-descriptors"></a>セキュリティ記述子

すべての名前付き Windows オブジェクトにセキュリティ記述子があります。名前のないオブジェクトもあります。 セキュリティ記述子には、オブジェクトの所有者とグループの Sid とその Acl が記述されています。

オブジェクトのセキュリティ記述子は、通常、オブジェクトを作成する関数によって作成されます。 ドライバーが[IoCreateDevice](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice)または[iocreate](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdmsec/nf-wdmsec-wdmlibiocreatedevicesecure)のルーチンを呼び出してデバイスオブジェクトを作成すると、システムによって、作成されたデバイスオブジェクトにセキュリティ記述子が適用され、オブジェクトの acl が設定されます。 ほとんどのデバイスでは、Acl はデバイス情報 (INF) ファイルで指定されています。

[」を参照し](https://docs.microsoft.com/windows-hardware/drivers/kernel/security-descriptors)てください。

### <a name="access-control-lists"></a>Access Control 一覧

Access Control リスト (Acl) を使用すると、オブジェクトへのアクセスをきめ細かく制御できます。 ACL は、各オブジェクトのセキュリティ記述子の一部です。

各 ACL には、0個以上の Access Control エントリ (ACE) が含まれています。 各 ACE には、ユーザー、グループ、またはコンピューター、およびその SID で拒否または許可される権限の一覧を識別する1つの SID が含まれています。

### <a name="acls-for-device-objects"></a>デバイスオブジェクトの Acl

デバイスオブジェクトの ACL は、次の3つの方法のいずれかで設定できます。

-   デバイスの種類の既定のセキュリティ記述子でを設定します。
-   **RtlCreateSecurityDescriptor**関数によってプログラムによって作成され、 **Rtlsetdaclsecuritydescriptor**関数によって設定されます。
-   デバイスの INF ファイルのセキュリティ記述子定義言語 (SDDL)、または**Iocreateデバイス**の呼び出しで指定されます。

すべてのドライバーは、デバイスオブジェクトの Acl を指定するために、INF ファイルで SDDL を使用する必要があります。

SDDL は、コンポーネントが文字列形式で Acl を作成できるようにする、拡張可能な記述言語です。 SDDL は、ユーザーモードとカーネルモードの両方のコードで使用されます。 次の図は、デバイスオブジェクトの SDDL 文字列の形式を示しています。

![デバイスオブジェクトの sddl 文字列](images/wsm-sddlstrings.gif)

アクセス値には、許可されるアクセスの種類を指定します。 SID 値は、アクセス値を適用する対象 (ユーザーやグループなど) を決定するセキュリティ識別子を指定します。

たとえば、次の SDDL 文字列を使用すると、システム (SY) へのアクセスが許可され、他のすべてのユーザー (WD) のみが読み取りアクセスできるようになります。

``` syntax
“D:P(A;;GA;;;SY)(A;;GR;;;WD)”
```

また、ヘッダーファイル wdmsec .h には、デバイスオブジェクトに適した定義済みの SDDL 文字列のセットも含まれています。 たとえば、次のように、ヘッダーファイルで SDDL\_DEVOBJ\_SYS\_すべて\_ADM\_RWX\_WORLD\_RWX\_RES\_RWX を定義します。

``` syntax
"D:P(A;;GA;;;SY)(A;;GRGWGX;;;BA)(A;;GRGWGX;;;WD)(A;;GRGWGX;;;RC)"
```

この文字列の最初のセグメントでは、カーネルとオペレーティングシステム (SY) がデバイスを完全に制御できます。 2番目のセグメントでは、組み込みの管理者グループ (BA) のすべてのユーザーがデバイス全体にアクセスできますが、ACL を変更することはできません。 3番目のセグメントでは、すべてのユーザー (WD) にデバイスの読み取りまたは書き込みを許可します。4番目のセグメントは、信頼されていないコード (RC) に対して同じ権限を付与します。 ドライバーは、定義済みの文字列をそのように使用することも、デバイスオブジェクト固有の文字列のモデルとして使用することもできます。

スタック内のすべてのデバイスオブジェクトは、同じ Acl を持つ必要があります。 スタック内の1つのデバイスオブジェクトの Acl を変更すると、デバイススタック全体の Acl が変更されます。

ただし、新しいデバイスオブジェクトをスタックに追加しても、新しいデバイスオブジェクトの Acl (Acl がある場合) またはスタック内の既存のデバイスオブジェクトの Acl は変更されません。 ドライバーが新しいデバイスオブジェクトを作成し、それをスタックの一番上にアタッチする場合、ドライバーは、次に低いドライバーから**DeviceObject**フィールドをコピーして、新しいデバイスオブジェクトにスタックの acl をコピーする必要があります。

**IocreateSY**のルーチンは、WD やなどの事前定義された sid を使用する SDDL 文字列のサブセットをサポートしています。 ユーザーモード Api と INF ファイルでは、完全な SDDL 構文がサポートされています。

### <a name="security-checks-using-acls"></a>Acl を使用したセキュリティチェック

プロセスがオブジェクトへのアクセスを要求すると、セキュリティチェックによって、オブジェクトの Acl が呼び出し元のアクセストークンの Sid と比較されます。

システムは、厳密なトップダウン順序で Ace を比較し、最初に関連する一致を停止します。 そのため、ACL を作成するときは、常に、対応する grant Ace の上に拒否 Ace を配置する必要があります。 次の例は、比較のしくみを示しています。

**例 1: ACL をアクセストークンと比較する**

例1は、システムが ACL を呼び出し元のプロセスのアクセストークンと比較する方法を示しています。 呼び出し元が、次の表に示す ACL を持つファイルを開こうとしているとします。

**サンプルファイルの ACL**

| Permission (アクセス許可) | SID        | アクセス権                |
|------------|------------|-----------------------|
| 許可      | アカウンティング | 書き込み、削除         |
| 許可      | 販売      | 追記                |
| 拒否       | 法務      | 追加、書き込み、削除 |
| 許可      | すべてのユーザー   | Read                  |

 

この ACL には、特に Accounting、Sales、法務、および Everyone グループに適用される4つの Ace があります。

次に、要求元のプロセスのアクセストークンには、次の順序で1つのユーザーと3つのグループの Sid が含まれているものとします。

ユーザー Jim (S-1-5-21...)

グループアカウンティング (S-1-5-22...)

有効なグループ (S-1-5-23...)

すべてのユーザーをグループ化 (S-1-1-0)

ファイルの ACL をアクセストークンと比較すると、システムはまず、ファイルの ACL でユーザー Jim の ACE を検索します。 [なし] が表示されるので、次に Accounting グループの ACE が検索されます。 前の表に示されているように、Accounting グループの ACE はファイルの ACL の最初のエントリとして表示されるため、Jim のプロセスにはファイルの書き込みまたは削除の権限が付与され、比較は停止します。 正当なグループの ACE ではなく、ACL の Accounting グループの ACE の前に、ファイルへの書き込み、追加、および削除のアクセスが拒否されます。

**例 2: ACL と制限付きトークンの比較**

システムは、制限されていないトークンと比較するのと同じ方法で ACL を制限付きトークンと比較します。 ただし、制限付きトークンの拒否 SID は、ACL 内の拒否 ACE とのみ一致することができます。

例2は、システムがファイルの ACL と制限付きトークンを比較する方法を示しています。 ファイルの ACL が、前の表に示されているものと同じであるとします。 ただし、この例では、次の Sid を含む制限付きトークンがプロセスに含まれています。

ユーザー Jim (S-1-5-21...)承諾

グループアカウンティング (S-1-5-22...)承諾

有効なグループ (S-1-5-23...)承諾

すべてのユーザーをグループ化 (S-1-1-0)

ファイルの ACL には、Jim の SID が表示されないので、システムはアカウンティンググループ SID に進みます。 ファイルの ACL には Accounting グループの ACE がありますが、この ACE はアクセスを許可します。そのため、プロセスの制限付きトークンの SID と一致しないため、アクセスが拒否されます。 その結果、システムは有効なグループ SID に進みます。 ファイルの ACL には、アクセスを拒否する法律グループの ACE が含まれているため、プロセスはファイルの書き込み、追加、または削除を行うことができません。

### <a name="privileges"></a>権限


特権とは、ユーザーがローカルコンピューター上でシステム関連の操作 (ドライバーの読み込み、時刻の変更、システムのシャットダウンなど) を実行する権限です。

特権は、オブジェクトではなくシステム関連のタスクおよびリソースに適用されるため、アクセス権とは異なります。また、特権は、オペレーティングシステムではなく、システム管理者によってユーザーまたはグループに割り当てられるためです。

各プロセスのアクセストークンには、プロセスに付与された特権の一覧が含まれています。 使用する前に、特権を明示的に有効にする必要があります。 特権の詳細については、カーネルドライバーのドキュメントの「[特権](https://docs.microsoft.com/windows-hardware/drivers/kernel/privileges)」を参照してください。

 

## <a name="span-idcreating-a-filespanspan-idcreating-a-filespanspan-idcreating-a-filespanwindows-security-model-scenario-creating-a-file"></a><span id="Creating-A-File"></span><span id="CREATING-A-FILE"></span><span id="creating-a-file"></span>Windows セキュリティモデルのシナリオ: ファイルの作成

システムは、プロセスがファイルまたはオブジェクトへのハンドルを作成するたびに、Windows セキュリティモデルに記述されているセキュリティコンストラクトを使用します。

次の図は、ユーザーモードプロセスがファイルを作成しようとしたときにトリガーされるセキュリティ関連のアクションを示しています。

![ファイルの作成例を次に示します。](images/wsm-creatingafile.gif)

前の図は、ユーザーモードアプリケーションが**CreateFile**関数を呼び出したときのシステムの応答を示しています。 次の注意事項は、図の丸で囲まれた数値を示しています。

1.  ユーザーモードアプリケーションは、正しい Microsoft Win32 ファイル名を渡して、 **CreateFile**関数を呼び出します。
2.  ユーザーモード Kernel32.dll は、要求を Ntdll に渡します。これにより、Win32 名が Microsoft Windows NT ファイル名に変換されます。
3.  Ntdll は、Windows ファイル名を使用して**Ntcreatefile**関数を呼び出します。 Ntoskrnl.exe 内で、i/o マネージャーが**Ntcreatefile**を処理します。
4.  I/o マネージャーは、要求をオブジェクトマネージャー呼び出しに再パッケージ化します。
5.  オブジェクトマネージャーは、シンボリックリンクを解決し、ファイルが作成されるパスに対するトラバーサル権限をユーザーが持っていることを確認します。 詳細については、「[オブジェクトマネージャーのセキュリティチェック](#omchecks)」を参照してください。
6.  オブジェクトマネージャーは、要求に関連付けられている基になるオブジェクト型を所有するシステムコンポーネントを呼び出します。 ファイル作成要求の場合、このコンポーネントは、デバイスオブジェクトを所有する i/o マネージャーです。
7.  I/o マネージャーは、デバイスオブジェクトのセキュリティ記述子をユーザーのプロセスのアクセストークンと照合して、ユーザーがデバイスに必要なアクセス権を持っていることを確認します。 詳細については、「 [I/o マネージャーのセキュリティチェック](#iomanchecks)」を参照してください。
8.  ユーザープロセスが必要なアクセス権を持っている場合は、i/o マネージャーによってハンドルが作成され、IRP\_MJ\_CREATE 要求がデバイスまたはファイルシステムのドライバーに送信されます。
9.  ドライバーは、必要に応じて追加のセキュリティチェックを実行します。 たとえば、要求によってデバイスの名前空間にオブジェクトが指定されている場合、ドライバーは、呼び出し元が必要なアクセス権を持っていることを確認する必要があります。 詳細については、「[ドライバーのセキュリティチェック](#driver)」を参照してください。

### <a name="span-idomchecksspanspan-idomchecksspansecurity-checks-in-the-object-manager"></a><span id="omchecks"></span><span id="OMCHECKS"></span>オブジェクトマネージャーでのセキュリティチェック

アクセス権を確認する責任は、このようなチェックを実行できる最上位レベルのコンポーネントに属しています。 オブジェクトマネージャーが呼び出し元のアクセス権を確認できる場合は、それが実行されます。 それ以外の場合、オブジェクトマネージャーは、基になるオブジェクトの種類を担うコンポーネントに要求を渡します。 そのコンポーネントは、可能であれば、アクセスを検証します。そうでない場合は、ドライバーなどの下位のコンポーネントに要求を渡します。

オブジェクトマネージャーは、イベントやミューテックスロックなど、単純なオブジェクト型の Acl をチェックします。 名前空間を持つオブジェクトの場合、型の所有者はセキュリティチェックを実行します。 たとえば、i/o マネージャーは、デバイスオブジェクトとファイルオブジェクトの種類の所有者と見なされます。 名前を解析するときに、オブジェクトマネージャーがデバイスオブジェクトまたはファイルオブジェクトの名前を見つけると、上記のファイル作成シナリオのように、名前が i/o マネージャーに渡されます。 その後、i/o マネージャーは、可能であればアクセス権を確認します。 名前にデバイスの名前空間内のオブジェクトが指定されている場合、i/o マネージャーはその名前をデバイス (またはファイルシステム) ドライバーに渡し、そのドライバーが要求されたアクセスの検証を担当します。

### <a name="span-idiomanchecksspanspan-idiomanchecksspansecurity-checks-in-the-io-manager"></a><span id="iomanchecks"></span><span id="IOMANCHECKS"></span>I/o マネージャーでのセキュリティチェック

I/o マネージャーによってハンドルが作成されると、プロセスアクセストークンに対してオブジェクトの権限がチェックされ、ユーザーに付与された権限がハンドルと共に格納されます。 I/o マネージャーは、後で i/o 要求を受信すると、そのハンドルに関連付けられている権限をチェックして、要求された i/o 操作を実行する権限がプロセスにあることを確認します。 たとえば、後で書き込み操作を要求する場合、i/o マネージャーは、そのハンドルに関連付けられている権限を調べて、呼び出し元にオブジェクトへの書き込みアクセス権があることを確認します。 

ハンドルが複製されている場合、そのコピーから権限を削除することはできますが、追加することはできません。

I/o マネージャーがオブジェクトを作成すると、汎用の Win32 アクセスモードがオブジェクト固有の権限に変換されます。 たとえば、ファイルとディレクトリには次の権限が適用されます。


| Win32 アクセスモード | オブジェクト固有の権限 |
|-------------------|------------------------|
|   汎用\_読み取り   |        ReadData        |
|  汎用\_書き込み   |       WriteData        |
| 汎用\_実行  |     ReadAttributes     |
|   汎用\_すべて    |          すべての           |
 
ファイルを作成するには、プロセスがターゲットパスの親ディレクトリに対するトラバーサル権限を持っている必要があります。 たとえば、\\デバイス\\CDROM0\\Directory\\file.txt を作成するには、プロセスに \\デバイス、\\デバイス\\CDROM0、\\デバイス\\CDROM0\\Directory を走査する権限が必要です。 I/o マネージャーは、これらのディレクトリのトラバーサル権限だけをチェックします。

I/o マネージャーは、ファイル名を解析するときに検査権限をチェックします。 ファイル名がシンボリックリンクの場合、i/o マネージャーはそれを完全パスに解決してから、ルートから開始して、トラバーサルの権限をチェックします。 たとえば、DosDevices\\D \\シンボリックリンクが Windows NT デバイス名 \\デバイス\\CDROM0 にマップされているとします。 プロセスは、\\デバイスディレクトリに対するトラバーサル権限を持っている必要があります。

詳細については、「[オブジェクトハンドル](https://docs.microsoft.com/windows-hardware/drivers/kernel/object-handles)と[オブジェクトのセキュリティ](https://docs.microsoft.com/windows-hardware/drivers/kernel/object-security)」を参照してください。

### <a name="span-iddriverspanspan-iddriverspansecurity-checks-in-the-driver"></a><span id="driver"></span><span id="DRIVER"></span>ドライバーのセキュリティチェック

オペレーティングシステムカーネルは、実質的には、すべてのドライバーを、独自の名前空間を持つファイルシステムとして扱います。 その結果、呼び出し元がデバイスの名前空間にオブジェクトを作成しようとすると、i/o マネージャーは、プロセスがパス内のディレクトリに対するトラバーサル権限を持っていることを確認します。 

WDM ドライバーでは、FILE_DEVICE_SECURE_OPEN を指定してデバイスオブジェクトが作成されていない限り、i/o マネージャーは名前空間に対するセキュリティチェックを実行しません。  FILE_DEVICE_SECURE_OPEN が設定されていない場合、ドライバーは名前空間のセキュリティを確保する役割を担います。 詳細については、「[デバイスの名前空間へのアクセス](https://docs.microsoft.com/windows-hardware/drivers/kernel/controlling-device-namespace-access)と[デバイスオブジェクトのセキュリティ保護](https://docs.microsoft.com/windows-hardware/drivers/kernel/securing-device-objects)」を参照してください。

WDF ドライバーの場合、FILE_DEVICE_SECURE_OPEN フラグは常に設定されるため、アプリケーションがデバイスの名前空間内の任意の名前にアクセスできるようになる前に、デバイスのセキュリティ記述子がチェックされます。 詳細については、「 [KMDF ドライバーでのデバイスアクセスの制御](https://docs.microsoft.com/windows-hardware/drivers/wdf/controlling-device-access-in-kmdf-drivers)」を参照してください。



## <a name="windows-security-boundaries"></a>Windows セキュリティ境界

相互に通信するドライバーと、異なる特権レベルのユーザーモードの呼び出し元は、信頼境界を越えていると見なすことができます。 信頼境界とは、下位の特権を持つプロセスから上位の特権を持つプロセスにまたがるコード実行パスのことです。

特権レベルの違いが大きいほど、対象となるドライバーやプロセスに対して特権昇格攻撃などの攻撃を実行する攻撃者にとって、境界はより興味深いものになります。

脅威モデルを作成するプロセスの一環として、セキュリティの境界を調べて、予期しないパスを探します。 詳細については、「[ドライバーの脅威のモデル](threat-modeling-for-drivers.md)化」を参照してください。 

信頼境界を越えるデータは信頼されていないため、検証する必要があります。 

この図は、3つのカーネルドライバーと2つのアプリを示しています。1つはアプリコンテナー内、もう1つは管理者権限で実行されるアプリです。 赤い線は、信頼の境界の例を示しています。

![アプリケーションコンテナーに1つずつ、3つのカーネルドライバーと2つのアプリを示すドライバーの攻撃対象領域](images/driver-security-attack-surface.png)

アプリコンテナーは追加の制約を提供でき、管理者レベルで実行されていないため、パス (1) は、アプリケーションコンテナー (非常に低い特権のプロセス) とカーネルドライバーの間で信頼境界が使用されるため、エスカレーション攻撃のリスクパスが高くなります。 

パス (2) は、アプリが管理者権限で実行されていて、カーネルドライバーに直接呼び出すので、低いリスクパスになります。 管理者は既にシステムに対して非常に高い特権を持っているため、管理者からカーネルへの攻撃は、攻撃者にとって興味深いターゲットではなく、注目すべき信頼境界になります。

パス (3) は、脅威モデルが作成されていない場合に失われる可能性がある複数の信頼境界を越えるコード実行パスの例です。
この例では、driver 1 と driver 3 の間に信頼境界があります。ドライバー1はユーザーモードアプリから入力を受け取り、ドライバー3に直接渡します。

ユーザーモードからドライバーに送られるすべての入力は信頼されていないため、検証する必要があります。 他のドライバーからの入力は、前のドライバーが単純なパススルーであるか (たとえば、アプリ1のドライバー1によって受信されたデータ)、ドライバー1はデータに対して検証を行わず、ドライバー3に渡すだけであったかによって信頼できない場合もあります。 完全な脅威モデルを作成することによって、すべての攻撃対象領域と信頼境界を特定し、それらをまたぐすべてのデータを検証してください。


## <a name="windows-security-model-recommendations"></a>Windows セキュリティモデルの推奨事項 

-   **Iocreateデバイス**のルーチンの呼び出しに強力な既定の acl を設定します。
-   各デバイスの INF ファイルで Acl を指定します。 これらの Acl は、必要に応じて、厳密な既定の Acl を緩めることができます。
-   デバイスオブジェクトのセキュリティ設定をデバイスの名前空間に適用するには、ファイル\_デバイス\_セキュリティで保護された\_オープン特性を設定します。
-   このようなアクセスが悪意を持って悪用されない限り、ファイル\_\_アクセスを許可する Ioctl は定義しないでください。
-   **IoValidateDeviceIoControlAccess**ルーチンを使用して、ファイル\_\_アクセスを許可する既存の ioctl のセキュリティを強化します。
-   脅威モデルを作成してセキュリティ境界を調べ、予期しないパスを探します。 詳細については、「[ドライバーの脅威のモデル](threat-modeling-for-drivers.md)化」を参照してください。 
-   ドライバーのセキュリティに関するその他の推奨事項については、[ドライバーのセキュリティチェックリスト](driver-security-checklist.md)


### <a name="see-also"></a>参照

[デバイスオブジェクトのセキュリティ保護](https://docs.microsoft.com/windows-hardware/drivers/kernel/securing-device-objects)

[ドライバーのセキュリティ チェックリスト](driver-security-checklist.md)







