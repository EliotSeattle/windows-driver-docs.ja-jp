---
title: ページング可能なコードまたはデータのロック
description: ページング可能なコードまたはデータのロック
ms.assetid: b99b6af3-b4b1-4fd6-ac73-27c1068183a4
keywords:
- ページング可能なドライバー WDK カーネル、コードまたはデータのロック
- ロックの WDK ページング可能なドライバー
- ページング可能な状態を復元します。
- 常駐コード WDK ページング可能なドライバー
- ページング可能なコードの分離
- ページ キーワード WDK
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: 3e6f93d8e998f3abdf99cfbfec14edcdba6fc7e0
ms.sourcegitcommit: 0cc5051945559a242d941a6f2799d161d8eba2a7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "63381362"
---
# <a name="locking-pageable-code-or-data"></a>ページング可能なコードまたはデータのロック





直列および並列のドライバーなど、特定のカーネル モード ドライバーを管理するデバイスが開いている場合を除き、メモリ常駐型にする必要はありません。 ただし、アクティブな接続またはポートがある、限りそのポートを管理するドライバー コードの一部は、デバイスのサービスを提供する常駐である必要があります。 ポートまたは接続が使用されていない、ときに、ドライバーのコードは必要ありません。 これに対し、システム コード、アプリケーション コード、またはシステムのページング ファイルを含むディスク用のドライバーをドライバーは常に、そのデバイスと、システムの間でデータを転送するためメモリ常駐型を必ずする必要があります。

(モデム) などの散発的に使用されるデバイスのドライバーは、管理対象デバイスがアクティブでないときにシステムの領域を解放できます。 1 つのセクションでアクティブなデバイスをサービスに常駐する必要があるコードを配置して、ドライバーでコードがメモリにロック、デバイスが使用されている場合は、このセクションをページング可能として指定することができます。 ドライバーのデバイスが開かれると、オペレーティング システムがメモリにページング可能なセクションを表示し、ドライバー ロックまでありますが不要になった。

システム CD オーディオ ドライバーのコードでは、この手法を使用します。 ドライバーのコードは、デバイスの製造元によってページング可能なセクションにグループ化されます。 特定のブランドこと、特定のシステム上に存在する場合があります。 また、CD-ROM がシステムに存在する場合でもからアクセスされる頻度が低い、CD の種類によってページング可能なセクションにコードをグループ化により、特定のコンピューター上に存在しないデバイス用にコードが読み込まれますことはありませんので。 ただし、デバイスがアクセスされると、システムは、適切なデバイス用のコードを読み込みます。 ドライバーの呼び出し後、 [ **MmLockPagableCodeSection** ](https://msdn.microsoft.com/library/windows/hardware/ff554601)ルーチンの説明に従って、以下にそのコードをそのデバイスの中にメモリにロックが使用されています。

で、名前付きセクションにページング可能なコードを特定するのには、次のコンパイラ ディレクティブでマークします。

**\#プラグマ アロケーション\_テキスト (ページ * Xxx**<em>、 *RoutineName</em>* *)**

ページング可能なコード セクションの名前が「ページ」の 4 つの文字で始まる必要があり、最大 4 つの文字の後に指定できます (表現として***Xxx***) セクションを一意に識別します。 セクション名 (つまり、「ページ」) の最初の 4 つの文字を大文字で入力する必要があります。 *RoutineName*ページング可能なセクションに含まれるエントリ ポイントを識別します。

ドライバー ファイルのページング可能なコード セクションの最短有効な名前は、単純にページです。 たとえば、次のコード例では、プラグマ ディレクティブを識別`RdrCreateConnection`エントリとしてページング可能なコード セクションがページをという名前でポイントします。

```cpp
#ifdef  ALLOC_PRAGMA 
#pragma alloc_text(PAGE, RdrCreateConnection) 
#endif 
```

ページング可能なドライバーのコードを常駐させるメモリ内でロックされているドライバーを呼び出すと[ **MmLockPagableCodeSection**](https://msdn.microsoft.com/library/windows/hardware/ff554601)、ページング可能なコードでは、アドレス (通常はドライバー ルーチンのエントリ ポイント) を渡すセクション。 **MmLockPagableCodeSection**の呼び出しで参照されているルーチンを含むセクションの内容全体をロックします。 つまり、この呼び出しによって、同じページに関連付けられたすべてのルーチン*Xxx*識別子が常駐しており、ロックされたメモリにします。

**MmLockPagableCodeSection**セクションのロックを解除するときに使用されるハンドルを返します (呼び出すことによって、 [ **MmUnlockPagableImageSection** ](https://msdn.microsoft.com/library/windows/hardware/ff556377)ルーチン) またはときに、ドライバーがからセクションをロックする必要がありますコード内の場所を追加します。

ドライバーとして扱うことも使用頻度の低いデータ ページング可能なすぎる、ページ アウトできますをサポートするデバイスがアクティブになるまでのようにします。 たとえば、システム ミキサーのドライバーは、ページング可能なデータを使用します。 ミキサーのデバイスには、このドライバーことができるように、データ ページング可能なは、それに関連付けられている非同期 I/O がありません。

ページング可能なデータ セクションの名前は、4 つの文字「ページ」で始まる必要があり、セクションを一意に識別するために最大 4 つの文字の後に指定できます。 セクション名 (つまり、「ページ」) の最初の 4 つの文字を大文字で入力する必要があります。

コードとデータ セクションに同一の名前を割り当てないでください。 ソース コードを読みやすく、するドライバー開発者向け通常に名前を割り当てるページ ページング可能なコード セクションの短い名前とさまざまなアロケーションに表示がありますので\_プラグマ ディレクティブのテキスト。 長い名前は、ページング可能なデータ セクションに割り当てられます (データ PAGEDATA など\_seg、bss に PAGEBSS\_seg など)、ドライバーが必要な場合があります。

たとえば、次のコード例では、最初の 2 つのプラグマ ディレクティブは、PAGEDATA と PAGEBSS 2 つのデータのページング可能なセクションを定義します。 PAGEDATA はデータを使用して宣言されている\_seg プラグマ ディレクティブと初期化されたデータが含まれています。 PAGEBSS が bss で宣言されている\_seg プラグマ ディレクティブと、初期化されていないデータが含まれています。

```cpp
#pragma data_seg("PAGEDATA")
#pragma bss_seg("PAGEBSS")

INT Variable1 = 1;
INT Variable2;

CHAR Array1[64*1024] = { 0 };
CHAR Array2[64*1024];

#pragma data_seg()
#pragma bss_seg()
```

このコード例では`Variable1`と`Array1`明示的に初期化され、PAGEDATA セクションではそのために配置されます。 `Variable2` `Array2`を暗黙的にゼロに初期化され、PAGEBSS セクションに配置されます。

ゼロにグローバル変数を暗黙的に初期化ディスク上の実行可能ファイルのサイズを縮小し、ゼロに明示的な初期化をお勧めします。 明示的なゼロ初期化は、特定のデータ セクションでは、変数を配置するために必要がある場合を除く避ける必要があります。

ドライバーの呼び出しでメモリ常駐データのセクションを作成して、メモリにロックする[ **MmLockPagableDataSection**](https://msdn.microsoft.com/library/windows/hardware/ff554607)、データ項目を渡すことがページング可能なデータ セクションに表示されます。 **MmLockPagableDataSection**後続ロックまたは要求をロック解除に使用するハンドルを返します。

ロックされているセクションのページング可能な状態を復元するには、呼び出す[ **MmUnlockPagableImageSection**](https://msdn.microsoft.com/library/windows/hardware/ff556377)、によって返されるハンドルの値を渡す[ **MmLockPagableCodeSection**](https://msdn.microsoft.com/library/windows/hardware/ff554601)または[ **MmLockPagableDataSection**](https://msdn.microsoft.com/library/windows/hardware/ff554607)必要に応じて、します。 ドライバーの[*アンロード*](https://msdn.microsoft.com/library/windows/hardware/ff564886)ルーチンを呼び出す必要があります**MmUnlockPagableImageSection**がコードとデータのセクションではロックを取得して各ハンドルを解放します。

メモリ マネージャーがメモリにページをロックする前に、読み込まれたモジュール一覧を検索する必要がありますので、負荷の高い操作は、セクションのロックです。 場合は、コード内のさまざまな場所からのセクションのロックのドライバーを使用するより効率的な[ **MmLockPagableSectionByHandle** ](https://msdn.microsoft.com/library/windows/hardware/ff554610)その最初の呼び出し後**MmLockPagable*Xxx*セクション**します。

渡されるハンドル**MmLockPagableSectionByHandle**以前の呼び出しによって返されたハンドルは、 **MmLockPagableCodeSection**または**MmLockPagableDataSection**します。

メモリ マネージャーの各セクションのハンドル カウントを維持し、ドライバーを呼び出すたびにこの数が増加**MmLockPagable * Xxx*** セクションです。 呼び出し**MmUnlockPagableImageSection**デクリメント カウントします。 セクション ハンドルのいずれかのカウンターが 0 以外の場合、そのセクションでロックされたメモリに残ります。

セクションを識別するハンドルは、そのドライバーが読み込まれている限り有効です。 そのため、ドライバーを呼び出す必要があります**MmLockPagable*Xxx*セクション**1 回だけです。 使用する場合は、ドライバーは、ロックの追加の呼び出しを必要とする**MmLockPagableSectionByHandle**します。

ドライバーは、いずれかを呼び出す場合**MmLockPagable * Xxx*** 既にロックされているセクションの日常的なメモリ マネージャーは、参照カウントをインクリメント セクション。 セクションがページ アウト ロック ルーチンが呼び出されたときに、メモリ マネージャーは、セクション内のページし、参照カウントを 1 に設定します。

この手法を使用するには、システム リソースには、ドライバーの影響を最小限に抑えられます。 ドライバーの実行時に、コードと常駐する必要があるデータをメモリにロックできます。 ときに (開かれている、またはデバイスが閉じられたときに、デバイスがない場合)、そのデバイスの未処理の I/O 要求がない、ドライバーは、同じコードまたはデータを利用できるようにすると、ページ アウト ロックを解除できます。

ただし、ドライバーが割り込みを接続すると、常に割り込みを処理中に呼び出すことができるドライバーのコードがメモリ常駐型である必要があります。 一部のデバイス ドライバーは、オンデマンド ページングやメモリにロックされている、行んだことができます、このようないくつかのコア セット ドライバーのコードとデータありますシステムの領域に完全に常駐しています。

コードまたはデータ セクションのロックに関する次の実装のガイドラインを検討してください。

- 主な用途、 **Mm (Un) ロック * Xxx*** ルーチンが通常の非ページ コードまたはデータ ページングを有効にするには非ページ コードまたはデータとしてで取り込まれたとします。 シリアル ドライバーと並列ドライバーなどのドライバーがその良い例: このようなドライバーを管理、デバイスに開いているハンドルがない場合、コードの部分は不要で、ページ アウトを維持できます。リダイレクターおよび server は、この手法を使用できるドライバーの良い例ではも。 アクティブな接続がない場合は、これらのコンポーネントの両方は、ページ アウト。

- まったくページング可能なセクションは、メモリにロックされています。

- コードの 1 つのセクションとデータ ドライバーごとに 1 つが効率的です。 名前付きのページング セクションの多くは、一般に効率的ではありません。

- 純粋なページング可能なセクションおよびページングがオンデマンドでロックされているセクションは個別のしてください。

- 注意して**MmLockPagableCodeSection**と**MmLockPagableDataSection**頻繁に呼び出す必要がありますはありません。 これらのルーチンで、メモリ マネージャー セクションの読み込み時に、大量の I/O アクティビティが生じる場合があります。 使用する場合は、ドライバーは、コード内の複数の場所からのセクションをロックする必要があります、 **MmLockPagableSectionByHandle**します。

 

 




