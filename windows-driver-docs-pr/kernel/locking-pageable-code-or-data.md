---
title: ページング可能なコードまたはデータのロック
description: ページング可能なコードまたはデータのロック
ms.assetid: b99b6af3-b4b1-4fd6-ac73-27c1068183a4
keywords:
- ページング可能ドライバー WDK カーネル、ロック (コードまたはデータの)
- WDK のページング可能ドライバーのロック
- ページング可能状態の復元
- 常駐コード WDK のページング可能ドライバー
- 分離 (ページング可能コードを)
- ページキーワード WDK
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: defae0a444790a0303ac3f09fbdcc2bdb91dba34
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72827900"
---
# <a name="locking-pageable-code-or-data"></a>ページング可能なコードまたはデータのロック





シリアルドライバーやパラレルドライバーなど、特定のカーネルモードドライバーは、管理対象のデバイスが開いていない限り、メモリ常駐型である必要はありません。 ただし、アクティブな接続またはポートがある限り、そのポートを管理するドライバーコードの一部は、デバイスを処理するために常駐している必要があります。 ポートまたは接続が使用されていない場合、ドライバーコードは必要ありません。 これに対して、システムコード、アプリケーションコード、またはシステムページングファイルを含むディスクのドライバーは、常にデバイスとシステムの間でデータが転送されるため、常にメモリ常駐型である必要があります。

断続的に使用されるデバイスのドライバー (モデムなど) は、管理対象のデバイスがアクティブでないときにシステム領域を解放できます。 アクティブなデバイスをサービスするために常駐する必要があるコードを1つのセクションに配置し、デバイスの使用中にドライバーがメモリ内のコードをロックする場合は、このセクションをページング可能として指定できます。 ドライバーのデバイスが開かれると、オペレーティングシステムはページング可能なセクションをメモリに取り込み、ドライバーは不要になったときにそのセクションをロックします。

この手法は、システム CD audio driver コードによって使用されます。 ドライバーのコードは、CD デバイスの製造元に応じて、ページング可能なセクションにグループ化されます。 特定のブランドが特定のシステムに存在しないことがあります。 また、CD-ROM がシステム上に存在する場合でも、頻繁にアクセスされる可能性があります。そのため、コードを CD の種類別のページング可能なセクションにグループ化すると、特定のコンピューターに存在しないデバイスのコードが読み込まれないようにすることができます。 ただし、デバイスにアクセスすると、システムによって適切な CD デバイスのコードが読み込まれます。 次に、ドライバーは、次に示すように[**MmLockPagableCodeSection**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmlockpagablecodesection)ルーチンを呼び出して、デバイスの使用中にコードをメモリにロックします。

ページング可能なコードを名前付きセクションに分離するには、次のコンパイラディレクティブを使用してマークします。

**\#pragma alloc\_text (PAGE * Xxx**<em>, *RoutineName</em>* *)* *

ページング可能なコードセクションの名前は、4文字の "PAGE" で始まる必要があります。また、セクションを一意に識別するために、最大4文字 (ここでは **_Xxx_** ) を指定できます。 セクション名の最初の4文字 (つまり、"PAGE") は大文字にする必要があります。 *RoutineName*は、ページング可能なセクションに含まれるエントリポイントを識別します。

ドライバーファイル内のページング可能なコードセクションの有効な最小の名前は単なるページです。 たとえば、次のコード例のプラグマディレクティブは、ページという名前のページング可能なコードセクションのエントリポイントとして `RdrCreateConnection` を識別します。

```cpp
#ifdef  ALLOC_PRAGMA 
#pragma alloc_text(PAGE, RdrCreateConnection) 
#endif 
```

ページング可能なドライバーコードをメモリ内に常駐させるために、ドライバーは[**MmLockPagableCodeSection**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmlockpagablecodesection)を呼び出し、ページング可能なコードセクションにあるアドレス (通常はドライバールーチンのエントリポイント) を渡します。 **MmLockPagableCodeSection**は、呼び出しで参照されるルーチンを含むセクションの内容全体をロックします。 つまり、この呼び出しにより、同じページ*Xxx*識別子に関連付けられたすべてのルーチンがメモリに常駐し、ロックされます。

**MmLockPagableCodeSection**は、セクションのロックを解除するとき ( [**MmUnlockPagableImageSection**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmunlockpagableimagesection)ルーチンを呼び出すことによって)、またはドライバーがコード内の他の場所からセクションをロックする必要がある場合に使用されるハンドルを返します。

また、ドライバーは、使用されていないデータをページング可能として扱うこともできます。これにより、サポートされているデバイスがアクティブになるまで、ページングされることもありません。 たとえば、システムミキサードライバーはページング可能なデータを使用します。 ミキサーデバイスには、非同期 i/o が関連付けられていないため、このドライバーはデータをページングできるようにします。

ページング可能なデータセクションの名前は、4文字の "ページ" で始まる必要があります。また、セクションを一意に識別するために、最大4文字の後に指定できます。 セクション名の最初の4文字 (つまり、"PAGE") は大文字にする必要があります。

コードセクションとデータセクションに同一の名前を割り当てないようにします。 ソースコードを読みやすくするために、通常、ドライバー開発者は名前ページをページング可能なコードセクションに割り当てます。これは、この名前が短く、多くの alloc\_text プラグマディレクティブに出現する可能性があるためです。 長い名前は、任意のページング可能なデータセクションに割り当てられます (たとえば、data\_seg の PAGEDATA、bss\_seg などの PAGEDATA など) が必要になる場合があります。

たとえば、次のコード例の最初の2つのプラグマディレクティブは、PAGEDATA と PAGEDATA という2つのページング可能なデータセクションを定義します。 PAGEDATA は、データ\_seg プラグマディレクティブを使用して宣言され、初期化されたデータを含んでいます。 PAGEBSS は bss\_seg プラグマディレクティブを使用して宣言され、初期化されていないデータが含まれています。

```cpp
#pragma data_seg("PAGEDATA")
#pragma bss_seg("PAGEBSS")

INT Variable1 = 1;
INT Variable2;

CHAR Array1[64*1024] = { 0 };
CHAR Array2[64*1024];

#pragma data_seg()
#pragma bss_seg()
```

このコード例では、`Variable1` と `Array1` が明示的に初期化されているため、PAGEDATA セクションに配置されます。 `Variable2` と `Array2` は暗黙的にゼロで初期化され、PAGEBSS セクションに配置されます。

グローバル変数を0に暗黙的に初期化すると、ディスク上の実行可能ファイルのサイズが縮小され、明示的な初期化よりも0にすることをお勧めします。 特定のデータセクションに変数を配置するために必要な場合を除き、明示的なゼロ初期化は避けてください。

データセクションをメモリ常駐型にしてメモリにロックするには、ドライバーは[**Mmlockpagabledatasection**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmlockpagabledatasection)呼び出し、ページング可能なデータセクションに表示されるデータ項目を渡します。 **Mmlockpagabledatasection**後のロックまたはロック解除要求で使用されるハンドルを返します。

ロックされたセクションのページング可能な状態を復元するには、 [**MmUnlockPagableImageSection**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmunlockpagableimagesection)を呼び出し、 [**MmLockPagableCodeSection**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmlockpagablecodesection)または[**mmlockpagabledatasection**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmlockpagabledatasection)よって返されるハンドル値を必要に応じて渡します。 ドライバーの[*アンロード*](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_unload)ルーチンは、 **MmUnlockPagableImageSection**を呼び出して、ロック可能なコードとデータセクションに対して取得した各ハンドルを解放する必要があります。

セクションのロックは、ページをメモリにロックする前に、読み込まれたモジュールリストをメモリマネージャーが検索する必要があるため、負荷の高い操作です。 ドライバーがコード内のさまざまな場所からセクションをロックする場合、 **Mmlockpagable*Xxx*セクション**への最初の呼び出しの後により効率的な[**MmLockPagableSectionByHandle**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ntddk/nf-ntddk-mmlockpagablesectionbyhandle)を使用する必要があります。

**MmLockPagableSectionByHandle**に渡されるハンドルは、 **MmLockPagableCodeSection**または**mmlockpagabledatasection**対する以前の呼び出しによって返されるハンドルです。

メモリマネージャーは、各セクションハンドルのカウントを保持し、ドライバーがそのセクションに対して**Mmlockpagable<em>Xxx</em>** を呼び出すたびにこのカウントをインクリメントします。 **MmUnlockPagableImageSection**を呼び出すと、カウントがデクリメントされます。 任意のセクションハンドルのカウンターが0以外の場合、そのセクションはメモリ内でロックされたままになります。

セクションへのハンドルは、そのドライバーが読み込まれている限り有効です。 そのため、ドライバーは**Mmlockpagable*Xxx*セクション**を1回だけ呼び出す必要があります。 ドライバーが追加のロック呼び出しを必要とする場合は、 **MmLockPagableSectionByHandle**を使用する必要があります。

既にロックされているセクションに対して、ドライバーが**Mmlockpagable<em>Xxx</em>** ルーチンを呼び出すと、メモリマネージャーはセクションの参照カウントをインクリメントします。 ロックルーチンが呼び出されたときにセクションがページアウトされた場合は、セクションの memory manager ページで、その参照カウントを1に設定します。

この手法を使用すると、ドライバーのシステムリソースへの影響が最小限に抑えられます。 ドライバーを実行すると、常駐させる必要があるコードとデータがメモリにロックされる可能性があります。 デバイスに対する未処理の i/o 要求がない場合 (つまり、デバイスが閉じられた場合や、デバイスが開かれたことがない場合)、ドライバーは同じコードまたはデータのロックを解除して、ページアウトを使用できるようにすることができます。

ただし、ドライバーが割り込みに接続した後は、割り込み処理中に呼び出すことができるドライバーコードは常にメモリ常駐型である必要があります。 一部のデバイスドライバーは、ページング可能にしたり、必要に応じてメモリにロックしたりすることができますが、このようなドライバーのコードやデータのコアセットは、システム領域に永続的に常駐する必要があります。

コードまたはデータセクションのロックについては、次の実装ガイドラインを考慮してください。

- **Mm (Un) ロック<em>Xxx</em>** ルーチンの主な用途は、通常の非ページコードまたはデータをページング可能にして、非ページ化コードやデータとして使用できるようにすることです。 シリアルドライバーやパラレルドライバーなどのドライバーは、良い例です。ドライバーが管理するデバイスに対して開いているハンドルがない場合、コードの一部は不要であり、ページアウトされたままになることがあります。リダイレクターとサーバーも、この手法を使用できるドライバーの好例です。 アクティブな接続がない場合は、これらのコンポーネントの両方をページアウトできます。

- ページング可能なセクション全体がメモリにロックされます。

- コードのセクションとドライバーごとのデータの1つのセクションは効率的です。 多くの名前付きのページング可能なセクションは、一般に非効率的です。

- 純粋にページング可能なセクションとページ分割されたが、必要に応じてロックされたセクションを分離します。

- **MmLockPagableCodeSection**と**Mmlockpagabledatasection**頻繁に呼び出さないでください。 これらのルーチンは、メモリマネージャーがセクションを読み込んだときに、大量の i/o アクティビティを発生させる可能性があります。 ドライバーがコード内の複数の場所からセクションをロックする必要がある場合は、 **MmLockPagableSectionByHandle**を使用する必要があります。

 

 




