---
title: カスタムの WMI イベントを使用します。
description: カスタムの WMI イベントを使用します。
ms.assetid: 00354e0b-a652-44e9-8b2b-fd755cc05fec
keywords:
- WMI の WDK カーネルでは、イベントの追跡
- WDK の WMI イベント
- WDK の WMI のトレース
- WMI イベントの送信
- イベントは、WDK の WMI をブロックします。
- WDK の WMI の通知
- WDK の WMI のイベント コンシューマー プロバイダー
- カスタム イベント WDK WMI
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: 792beb8c0a4541ef0803eac279e439ea14895d05
ms.sourcegitcommit: a33b7978e22d5bb9f65ca7056f955319049a2e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/31/2019
ms.locfileid: "56551221"
---
# <a name="using-custom-wmi-events"></a>カスタムの WMI イベントを使用します。





ドライバーの一部のクラスが特定の WMI イベント クラスをサポートするために必要です。 ドライバーは、独自のカスタムの WMI イベント クラスを設計することもできます。 カスタムの WMI イベントは、ドライバーにデータをユーザー モード コンポーネントに渡すための手段を提供します。 ユーザー モード コンポーネントは、WMI COM インターフェイスを通じて WMI イベントを受け取ります。

アプリケーションでは、次のようにイベント通知を受信できます。

-   使用して、 **CoCreateInstance**ルーチンへのポインターを取得する、**セグ: 前**オブジェクト。

-   使用して、**セグ: 前**WMI サーバー プロセスへの接続へのポインター。 **IWBemLocator::ConnectServer**メソッド呼び出しへのポインターを提供します。、 **IWbemServices**オブジェクト。

-   使用して、 **IWbemServices**興味のあるイベントの種類を照会するオブジェクト。 **IWbemServices::ExecNotificationQuery**メソッドでは、WMI クエリ言語 (WQL) でイベント クエリを指定できます。

-   WMI イベントを実装することで、非同期的に受信するアプリケーションを登録できますも、 **IWbemObjectSink**インターフェイス。 アプリケーションを使用して、 **iwbemservices::execnotificationqueryasync**イベントの非同期通知を登録します。 一致するイベントが発生すると、システムを使用して、 **IWbemObjectSink::Indicate**発生したイベントのアプリケーションに通知するメソッド。

ユーザー モードの WMI を実装することもできます。*イベント コンシューマー プロバイダー*します。 これは、WMI 読み込むことができる自動的に指定した型のイベントが発生したときにユーザー モード コンポーネントです。

-   インスタンスを含める、  **\_ \_EventConsumerProviderRegistration** MOF データ、ユーザー モード コンポーネントの WMI クラスです。

-   実装、 **IWbemUnboundObjectSink**の通知を受信する各 WMI イベント クラスのインターフェイス。

-   実装、 **IWbemEventConsumerProvider**イベント クラス、コンポーネントを指定するインターフェイスの受信の通知および関連付けられている**IWbemUnboundObjectSink**実装します。

-   実装、 **IWbemProviderInit**をイベント コンシューマーとしてコンポーネントを初期化するインターフェイス。

WMI イベントの受信の詳細について、 **IWbemXxx** COM インターフェイスは、Microsoft Windows SDK ドキュメントで見つかんだことができます。

WMI イベントは、特定の状況が発生したときに、ユーザー モード アプリケーションを通知する唯一の方法ではありません。 ドライバーは、アプリケーションが通知のポーリングに使用できる IOCTL で実装できます。 通知イベント オブジェクトを共有してでした、ドライバーとアプリケーション (を参照してください[イベント オブジェクト](event-objects.md)) を特定の状況が発生したことを通知します。

WMI イベントには、これら他の方法をいくつかの利点があります。

-   ユーザー モード アプリケーションは、ドライバーが応答できるよりも高速イベントのポーリングをしている場合、ドライバーは保留中の多くの Ioctl にがあります。

-   ユーザー モードのアプリケーションに通知する通知イベント オブジェクトを使用して、前の問題を改善することができますが、通知イベントがイベントが発生したことを通知できますのみ。 アプリケーションで、IOCTL を使用すると、その他のデータを取得するのに必要があります。 次の 2 つの問題が引き続き適用されます。

-   イベント用のドライバーのポーリングの複数のアプリケーションの場合、ドライバーをどのアプリケーションがイベントを受信確認の状態を維持する必要があります。

-   SCSI ミニポートや NDIS ミニポート ドライバーなど、一部のドライバーでは、Ioctl を受信できません。

WMI のイベントがユーザー モード コードを提供する必要がありますが、他の方法の場合よりもかなり複雑であるという欠点があります。

 

 




