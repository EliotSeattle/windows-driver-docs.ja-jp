---
title: CLFS の安定した記憶域
description: CLFS の安定した記憶域
ms.assetid: d0ee4f22-9fba-47da-a9c9-eaf3a21feb36
keywords:
- 共通ログファイルシステム WDK カーネル、安定ストレージ
- CLFS WDK カーネル、安定ストレージ
- 安定したストレージ WDK CLFS
- storage WDK CLFS
- コンテナー WDK CLFS
- 論理コンテナー WDK CLFS
- 物理コンテナーの WDK CLFS
- ログ i/o ブロック WDK CLFS
- WDK CLFS をブロックする
- ブロックオフセット WDK CLFS
- WDK CLFS をログに記録する
- 物理ログ WDK CLFS
- コンテナー識別子 WDK CLFS
- レコードシーケンス番号 (WDK CLFS)
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: cbff02b84ae87288d52d16616ebf0ea480d3d065
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72837112"
---
# <a name="clfs-stable-storage"></a>CLFS の安定した記憶域





レコードを共通ログファイルシステム (CLFS) ストリームに書き込むと、そのレコードは揮発性メモリのログ i/o ブロック (マーシャリング領域内) に配置されます。 CLFS は、定期的に、マーシャリング領域からディスクなどの安定したストレージにログ i/o ブロックをフラッシュします。 安定したストレージデバイスでは、ログは一連のコンテナーで構成されます。各コンテナーは、物理メディア上の連続したエクステントです。 ストリームの安定したストレージを形成するコンテナーのコレクションは、*ログ*または*物理ログ*と呼ばれます。

次の図は、コンテナーを示しています。

![コンテナー、ブロック、およびレコードを示す図](images/clfscontainers.gif)

上の図は、3つのログ i/o ブロックを保持するコンテナーを示しています。 最初のログ i/o ブロックには3つのレコードが含まれ、2番目のレコードには5つのレコード、3番目のレコードには2つのレコードが含まれます。 図に示すように、各ログ i/o ブロックの開始は常に安定したストレージメディアのセクターの先頭に合わせて調整されます。 安定したストレージ上のログ i/o ブロックはサイズが異なることに注意してください。

CLFS は、3つの数値のセットを使用してログ内のレコードを検索します。

-   *コンテナー識別子*は、レコードを保持するコンテナーを識別します。

-   *ブロックオフセット*は、コンテナー内の、レコードを保持するログ i/o ブロックの先頭のバイトオフセットを示します。

-   *レコードシーケンス*番号は、ログ i/o ブロック内のレコードを識別します。

CLFS ログレコードのログシーケンス番号 (LSN) には、実際には、コンテナー識別子、ブロックオフセット、レコードシーケンス番号という3つの情報が保持されます。 ただし、ログクライアントに指定された Lsn には、安定したストレージ上のレコードにアクセスする前に、CLFS が物理コンテナー識別子にマップする必要がある*論理コンテナー識別子*が含まれています。

CLFS は論理コンテナー識別子を使用して、ログレコードが進行中の一連のコンテナーに書き込まれるビューをクライアントに提供します。実際には、物理コンテナーがリサイクルされます。

たとえば、ログに3つのコンテナーがあり、1つのクライアントが CLFS レコードをログに書き込んでいるとします。 次のシナリオは、コンテナーをリサイクルする方法を示しています。

1.  クライアントは、3つのすべてのコンテナーを埋めるために十分なログレコードを書き込みます。

2.  クライアントは、( [**ClfsAdvanceLogBase**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-clfsadvancelogbase)または[**ClfsWriteRestartArea**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-clfswriterestartarea)を呼び出すことによって) ログベースをコンテナー2のレコードのいずれかに設定します。 これにより、クライアントは、コンテナー1内のレコードが不要になったことを伝えます。

3.  クライアントは、別のレコードをログに書き込み、新しく書き込まれたレコードの LSN を取得します。 その LSN の論理コンテナー識別子は4です。 レコードが安定したストレージにフラッシュされると、クライアントが論理コンテナー4で認識したレコードは、物理コンテナー1に移行します。

次の図は、このシナリオを示しています。この図は、論理コンテナーのクライアントシーケンスが安定したストレージ上の物理コンテナーにどのようにマップされるかを示しています。

![論理コンテナーと物理コンテナーを示す図](images/clfslogicalcontainers.gif)

論理コンテナー識別子、ブロックオフセット、およびレコードシーケンス番号は、特定のストリームの lsn が常に増加するシーケンスを形成するように、LSN に格納されます。 つまり、ストリームに書き込まれるログレコードの LSN (論理コンテナー識別子を持つ) は、その同じストリームに以前に書き込まれたログレコードの LSN よりも常に大きくなります。 次に、Lsn は2つの目的を提供します。 1) ストリームのクライアントに、順序付けられた一連のレコード識別子を提供し、2) 安定したストレージ上のレコードの場所を CLFS に提供します。

レコードの LSN を指定すると、次の関数を呼び出すことによって、論理コンテナー識別子、ブロックオフセット、およびレコードシーケンス番号を抽出できます。

[**ClfsLsnContainer**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-clfslsncontainer)

[**ClfsLsnBlockOffset**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-clfslsnblockoffset)

[**ClfsLsnRecordSequence**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-clfslsnrecordsequence)

論理コンテナー識別子は32ビットの数値であるため、2 ^ 32 個の可能な論理コンテナー識別子があり、それらは0x0 から0xFFFFFFFF までの範囲に含まれています。 1つのストリームには、最大で 2 ^ 32 個の論理コンテナーを含めることができます。

ブロックオフセットは、LSN の23ビットで格納されますが、 **Clfslsnblockoffset**は、安定したストレージメディアのセクターサイズに合わせて32ビットの数値を返します。 ブロックオフセットは常に512の倍数です。 また、ブロックオフセットは、安定したストレージメディアのセクターサイズに合わせて調整されます。 たとえば、セクターサイズが1024バイトの場合、ブロックオフセットは1024の倍数になります。

レコードシーケンス番号は9ビットの数値なので、2 ^ 9 (512) の有効なレコードシーケンス番号があり、これらは 0x0 ~ 0x1FF の範囲内です。 ログ i/o ブロックには、最大で512のレコードを含めることができます。

 

 




