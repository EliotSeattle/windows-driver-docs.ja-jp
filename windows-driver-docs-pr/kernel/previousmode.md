---
title: PreviousMode
description: PreviousMode
ms.assetid: 1251cca9-604c-48c0-a136-21dd1fe4fa72
keywords:
- PreviousMode
- Irp->requestormode
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: 1ede78ca07a562360d9cb170109f1c38f4374497
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72838493"
---
# <a name="previousmode"></a>PreviousMode


ユーザーモードアプリケーションがネイティブシステムサービスルーチンの**Nt**または**Zw**バージョンを呼び出すと、システム呼び出しメカニズムによって、呼び出し元のスレッドがカーネルモードにトラップされます。 パラメーター値がユーザーモードで開始されたことを示すために、システム呼び出しのトラップハンドラーは、呼び出し元の[スレッドオブジェクト](introduction-to-thread-objects.md)の前の**モード**フィールドをユーザーモードに設定し**ます。** ネイティブシステムサービスルーチンは、呼び出し元のスレッドの [前の**モード**] フィールドをチェックして、パラメーターがユーザーモードのソースからのものかどうかを判断します。

カーネルモードドライバーがネイティブシステムサービスルーチンを呼び出し、カーネルモードソースからのルーチンにパラメーター値を渡す場合、ドライバーは、現在のスレッドオブジェクトの前の**モード**フィールドが**kernelmode で**に設定されていることを確認する必要があります。

カーネルモードドライバーは任意のスレッドのコンテキストで実行できます。また、このスレッドの [前の**モード**] フィールドは、[モード] に設定**されて**いる可能性があります。 このような状況では、カーネルモードのドライバーは、ネイティブシステムサービスルーチンの**Zw**バージョンを呼び出して、パラメーター値が信頼されたカーネルモードのソースからのものであることをルーチンに知らせることができます。 **Zw**呼び出しは、現在のスレッドオブジェクトの前の**モード**値をオーバーライドする thin ラッパー関数に移動します。 ラッパー関数は、前の**モード**を**kernelmode で**に設定し、そのルーチンの**Nt**バージョンを呼び出します。 **Nt**バージョンのルーチンから制御が戻ったときに、ラッパー関数はスレッドオブジェクトの元の前の**モード**値を復元し、を返します。

カーネルモードドライバーは、ネイティブシステムサービスルーチンの**Nt**バージョンを直接呼び出すことができます。 カーネルモードドライバーは、ユーザーモードまたはカーネルモードで発生する可能性がある i/o 要求を処理するときに、現在のスレッドの前の**モード**値が呼び出し中に変更されないように、ドライバーは**Nt**バージョンのルーチンを呼び出すことができます。 **Nt * Xxx*** ルーチンは、呼び出し元スレッドの前の**モード**値をチェックして、パラメーター値がユーザーモードアプリケーションとカーネルモードコンポーネントのどちらであるかを判断し、それに応じて処理します。

カーネルモードドライバーが**Nt * Xxx*** ルーチンを呼び出し、現在のスレッドオブジェクトの前の**モード**値が、パラメーター値がユーザーモードまたはカーネルモードのソースからのものであるかどうかを正確に示していない場合に、エラーが発生することがあります。

たとえば、カーネルモードドライバーが任意のスレッドのコンテキストで実行されていて、このスレッドの前の**モード**値が **"モード"** に設定されているとします。 ドライバーがカーネルモードのファイルハンドルを[**Ntclose**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntclose)ルーチンに渡す場合、このルーチンは、前の**モード**の値をチェックし、ハンドルがユーザーモードハンドルである必要があると判断します。 **Ntclose**がユーザーモードハンドルテーブル内のハンドルを見つけられない場合、エラーコード\_ハンドル\_無効な状態を返します。 一方、ドライバーは、閉じられていないカーネルモードハンドルをリークします。

別の例として、 **Nt * Xxx*** ルーチンのパラメーターに入力バッファーまたは出力バッファーが含まれていて、前の = **モード**で ProbeForRead が使用されて**いる場合、** ルーチンは[](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread)または[**ProbeForWrite**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite)ルーチンを呼び出してバッファーを検証します。 バッファーがユーザーモードメモリではなくシステムメモリに割り当てられた場合、 **ProbeFor * xxx*** ルーチンによって例外が発生し、 **Nt * xxx*** ルーチンはステータス\_アクセス\_違反エラーコードを返します。

必要に応じて、ドライバーは[**Exgetの**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-exgetpreviousmode)前のモードルーチンを呼び出して、現在のスレッドオブジェクトから前の**モード**の値を取得できます。 または、ドライバーは、要求された i/o 操作を記述する[**IRP**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp)構造体から**irp->requestormode**フィールドを読み取ることができます。 **Irp->requestormode**フィールドには、操作を要求したスレッドからの、前の**モード**値のコピーが含まれています。

 

 




