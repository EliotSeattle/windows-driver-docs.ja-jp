---
title: CLFS の関連用語
description: 次の一覧は、共通ログファイルシステム (CLFS) のドキュメントで使用される主な用語の定義を示しています。
Robots: noindex, nofollow
ms.assetid: d8511c5a-0181-4c54-acdc-e8a5892bb620
keywords:
- WDK カーネル、用語の共通ログファイルシステム
- CLFS WDK カーネル、用語集
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: 96c41d15b038d037c485dfa028a52736e57c66a1
ms.sourcegitcommit: b316c97bafade8b76d5d3c30d48496915709a9df
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/13/2020
ms.locfileid: "79242945"
---
# <a name="clfs-terminology"></a>CLFS の関連用語


次の一覧は、共通ログファイルシステム (CLFS) のドキュメントで使用される主な用語の定義を示しています。 これらの定義は、CLFS の説明の間に適用されますが、それ以外の場合は適用されません。 これらの用語の多くは、ここで指定されている定義とは異なる他のテクノロジのコンテキストにおいて、一般的な意味や意味を持ちます。

<a href="" id="kernel-clfs-term-container"></a>**コンテナー**  
物理ディスクまたはその他の安定したストレージメディアの連続したエクステント。 たとえば、コンテナーは連続したディスクファイルにすることができます。

<a href="" id="kernel-clfs-term-sector"></a>**分野**  
物理ストレージメディアのアトミック i/o の単位です。 セクターのサイズは、特定の記憶装置のプロパティです。 たとえば、ハードディスクのセクターサイズは512バイトになります。

<a href="" id="kernel-clfs-term-log"></a>**出力**  
基本ファイルと、論理的に順序付けられた一連のコンテナーのセット。 ベースファイルはログのメタデータを保持し、コンテナーはログレコードを保持します。 すべてのコンテナーのサイズは同じです。

<a href="" id="kernel-clfs-term-client"></a>**client**  
CLFS ログを使用するアプリケーション、ドライバー、スレッド、またはその他のソフトウェアユニット。

<a href="" id="kernel-clfs-term-record"></a>**録音**  
クライアントがログに対して追加または読み取りを行うことができるデータの単位。

<a href="" id="kernel-clfs-term-stream"></a>**一連**  
ログ内のレコードの順序付けられたサブセット。 ログには、1つまたは複数のストリームを含めることができます。 クライアントは、特定のストリームに対してレコードの追加と読み取りを行います。 特定のストリーム内のレコードを比較して、書き込まれた順序を特定することができます。 異なるストリームのレコードを比較することはできません。 1つのストリームに複数のクライアントを含めることができます。 たとえば、複数のスレッドで1つのストリームにレコードを追加できます。 クライアントに対しては、ストリームはログ全体であるかのように見えます。

<a href="" id="kernel-clfs-term-dedicated-log"></a>**専用ログ**  
1つのストリームのみを持つことができるログ。

<a href="" id="kernel-clfs-term-multiplexed-log"></a>**多重化ログ**  
複数のストリームを含むことができるログ。

<a href="" id="kernel-clfs-term-log-i-o-block"></a>**ログ i/o ブロック**  
CLFS が安定したストレージにアトミックに書き込まれたレコードのセットを収集するバッファー。

<a href="" id="kernel-clfs-term-marshalling-area"></a>**マーシャリング領域**  
ログレコードを収集して安定したストレージに書き込むために CLFS クライアントによって作成、管理、およびスケジュールされるログ i/o ブロックのセット。 揮発性メモリで特定のマーシャリング領域に割り当てられたログ i/o ブロックは、すべて同じサイズです。

**注**   特定のマーシャリング領域のすべてのログ i/o ブロック (揮発性メモリ) が同じサイズであっても、安定したストレージに書き込まれる (そのマーシャリング領域から) ログ i/o ブロックのサイズは異なります。 たとえば、ログ i/o ブロックがいっぱいになる前に安定したストレージに強制された場合、そのブロックの使用されている部分だけが安定したストレージに書き込まれます。

 

<a href="" id="kernel-clfs-term-log-sequence-number--lsn"></a>**ログシーケンス番号 (LSN)**  
特定のストリーム内のログレコードを一意に識別する値を保持する不透明な構造体。 クライアントは、ストリームにレコードを書き込むときに、後でレコードを識別するために使用できる LSN を返します。 CLFS がストリームのレコードに割り当てる Lsn は、増加するシーケンスを形成します。 つまり、ストリーム内のレコードに割り当てられた LSN は、その同じストリームに以前に書き込まれたレコードに割り当てられた LSN よりも常に大きくなります。

   ストリーム間のレコードは比較できない**ことに注意**してください。 つまり、異なるストリームの2つのレコードの Lsn を比較して、最初に書き込まれたレコードを特定することはできません。

 

<a href="" id="kernel-clfs-term-base-lsn"></a>**ベース LSN**  
ストリームのクライアントが依然として必要とする、ストリーム内の最も古いレコードの LSN。 クライアントは、ベース LSN の更新を担当します。

<a href="" id="kernel-clfs-term-last-lsn"></a>**最後の LSN**  
ストリームのクライアントが依然として必要とする、ストリーム内の最も若いレコードの LSN。 通常、これは最後にストリームに書き込まれたレコードですが、クライアントには、ストリーム内の以前のレコードを指すように最後の LSN を手動で設定するオプションがあります。 最後の LSN を手動で前のレコードに設定することを、ストリームの*切り捨て*と呼びます。

<a href="" id="kernel-clfs-term-archive-tail"></a>**アーカイブテール**  
アーカイブが行われていないログ内の最も古いレコードの LSN。 すべてのログにアーカイブテールがあるわけではありません。 アーカイブテールのないログは*短期*と呼ばれ、アーカイブテールを含むログは*非短期*と呼ばれます。 クライアントは、ログにアーカイブテールがあることを指定すると、クライアントはアーカイブテールを更新します。

<a href="" id="kernel-clfs-term-active-portion-of-a-stream"></a>**ストリームのアクティブな部分**  
現在クライアントによって使用されているストリームの部分。 アクティブな部分は、基本 LSN または archive の末尾のいずれか小さい方が指すレコードで始まります。 アクティブな部分は、最後の LSN が指すレコードで終わります。

 

 




