---
title: エクスポート ドライバーの作成
description: エクスポート ドライバーの作成
ms.assetid: 60ce7d0d-0eab-4af6-890a-45ab206816aa
keywords:
- エクスポートドライバーの WDK カーネル
- エクスポートドライバーの読み込み (WDK カーネル)
- export driver 関数をインポートしています
- モジュール定義ファイルの WDK カーネル
- .def ファイル
- def ファイル
- カーネルモードドライバー WDK、エクスポートドライバー
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: 3147712503f4356519c41b5dbc09b6a96d70742b
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72828449"
---
# <a name="creating-export-drivers"></a>エクスポート ドライバーの作成





Microsoft Windows ドライバーは、通常、ポート/ミニポートドライバーのペア、クラス/miniclass ドライバーのペアなどのコンポーネントのペアとして定義されます。 通常、Microsoft はハードウェアに依存しないクラスまたはポートドライバーを提供し、ベンダーはハードウェアに依存する miniclass またはミニポートドライバーを提供します。

カーネルモードエクスポートドライバーは、基礎となるスタックやハードウェアの特性に依存しないドライバーペアの一部を実装する場合に特に適しています。これは、エクスポートドライバーはカーネルモード DLL であり、他のさまざまな方法で読み込むことができるためです。ハードウェア固有またはデバイススタック固有のコンポーネント。 Microsoft は、このカテゴリに分類される Windows オペレーティングシステムと共に複数のドライバーを提供しています。 たとえば、SCSI ポートドライバー、テープクラスドライバー、IDE コントローラードライバーは、システムによって提供されるすべてのエクスポートドライバーで、他のドライバーによって読み込まれています。

完全なカーネルモードドライバーの特性の多くが、エクスポートドライバーに不足しています。 エクスポートドライバにはディスパッチテーブルがありません。ドライバースタックには位置がありません。また、システムサービスとして定義されているサービスコントロールマネージャのデータベースにエントリがありません。 エクスポートドライバーには[**driverentry**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_initialize)ルーチンがありますが、その**driverentry**ルーチンは呼び出されません。 (ルーチンは、ビルドスクリプトの要件を満たすスタブにすぎません)。

エクスポートドライバーにディスパッチテーブルがない場合でも、ディスパッチルーチンを標準ドライバーに渡すことができます。 標準ドライバーは、ディスパッチルーチンを独自のディスパッチテーブルに挿入します。

標準ドライバーは、エクスポートドライバーとしても機能します。 ドライバーを両方の方法で機能させるには、ドライバーをエクスポートドライバーとして作成し、通常のドライバーとして読み込む必要があります。

### <a name="building-an-export-driver"></a>エクスポートドライバーの構築

ドライバーをエクスポートドライバーとしてビルドするには、ドライバーのソースファイルで複数のビルドユーティリティマクロを定義する必要があります。

まず、次のように、 **TARGETTYPE**マクロに適切な値を割り当てる必要があります。

```cpp
TARGETTYPE=EXPORT_DRIVER
```

また、 **Dlldef**マクロを使用して、モジュール定義 (.def) ファイルを指定する必要があります。 次に、例を示します。

```cpp
DLLDEF="c:\project\driver.def"
```

モジュール定義ファイルは、コンパイラとリンカーに、エクスポートされたルーチンの一覧とその他の情報を提供します。 モジュール定義ファイルの詳細については、Microsoft の Visual C++ドキュメントを参照してください。

ユーザーモードの DLL の構築に使用されるビルドユーティリティマクロの多くは、カーネルモードの DLL をビルドするときには使用できません。 

たとえば、カーネルモードの DLL のエントリポイントは常に**DllInitialize**です。 DLL が読み込まれた直後に、システムはカーネルモードの DLL の DllInitialize ルーチンを呼び出します。 エクスポートドライバーは、 **DllInitialize**ルーチンを提供する必要があります。 **DllInitialize**ルーチンを使用して、DLL 内の他のルーチンが必要とするリソースを取得または初期化できます。 

**Dllentry**マクロを使用してエントリポイントを指定することはできません。 

```cpp
NTSTATUS DllInitialize(
  _In_ PUNICODE_STRING RegistryPath
);
```
RegistryPath は、DLL のレジストリキー **HKEY_LOCAL_MACHINE\CurrentControlSet\Services\DllName**へのパスを指定する、カウントされた Unicode 文字列へのポインターです。 DLL ルーチンは、このキーを使用して DLL 固有の情報を格納できます。 RegistryPath が指すバッファーは、 **DllInitialize**が終了すると解放されます。 そのため、DLL でキーを使用する場合、 **DllInitialize**はキー名を複製する必要があります。 


ビルドプロセスでは、拡張子が .lib のエクスポートライブラリと、拡張子が .sys のエクスポートドライバーが生成されます。

### <a name="importing-functions-from-an-export-driver"></a>エクスポートドライバーからの関数のインポート

エクスポートドライバーによってエクスポートされる関数をインポートするには、DECLSPEC\_IMPORT マクロを使用して関数を宣言する必要があります。このマクロは、Ntdef. h で定義されています。 次に、例を示します。

```cpp
DECLSPEC_IMPORT int LoadPrinterDriver (int arg1); 
```

このマクロは、必要な場合には、これらのプラットフォームでの **\_\_declspec**(dllimport) ストレージクラス宣言に解決されます。これらのプラットフォームでは、必要がない場合は何も処理されません。

エクスポートドライバーでは、エクスポートされる関数は、DECLSPEC\_EXPORT マクロを使用して宣言する必要があります。 このマクロは、必要な場合には、これらのプラットフォーム上での **\_\_declspec**(dllexport) ストレージクラス宣言に解決されます。これらのプラットフォームでは、必要がない場合は何もしません。 エクスポートドライバーによって標準ドライバーにディスパッチルーチンが提供される場合、そのルーチンをエクスポートする必要はありません。

### <a name="loading-and-unloading-an-export-driver"></a>エクスポートドライバーの読み込みとアンロード

エクスポートドライバは、% Windir%\\System32\\Drivers ディレクトリにインストールする必要があります。 Windows 2000 以降では、オペレーティングシステムは、エクスポートドライバーの機能が他のドライバーによってインポートされた回数を示す参照カウントを保持します。 システムは、インポートするドライバーのいずれかがアンロードされるたびに、このカウントをデクリメントします。 参照カウントがゼロになると、エクスポートドライバーがアンロードされます。 ただし、エクスポートドライバーには、標準のエントリポイントとアンロードルーチン、 **DllInitialize**および**dllunload**が含まれている必要があります。また、オペレーティングシステムはこの参照カウントメカニズムをアクティブ化しません。

DLL のアンロード時に、システムはカーネルモード DLL の DllUnload ルーチンを呼び出します。

```cpp
NTSTATUS DllUnload(void);
```
エクスポートドライバーは、DllUnload ルーチンを提供する必要があります。 DLL 内のルーチンで使用されるすべてのリソースを解放するには、DllUnload ルーチンを使用します。 








