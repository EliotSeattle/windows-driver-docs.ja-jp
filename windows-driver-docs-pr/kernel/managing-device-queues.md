---
title: デバイス キューの管理
description: デバイス キューの管理
ms.assetid: 8b7d39f8-0449-4e9b-a54c-fe60ee60842c
keywords:
- デバイスが WDK Irp をキューに置いて管理
- 補足の IRP キュー WDK カーネル
- StartIo ルーチン、追加デバイスキュー
ms.date: 06/16/2017
ms.localizationpriority: medium
ms.openlocfilehash: c3b2a6b638309f8d7e4cf08c03fb7e33db7ee2ff
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72827880"
---
# <a name="managing-device-queues"></a>デバイス キューの管理





通常、i/o マネージャー (FSDs を除く) は、ドライバーが[**IoCreateDevice**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-iocreatedevice)を呼び出したときに、関連付けられたデバイスキューオブジェクトを作成します。 また、 [**iostartpacket**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-iostartpacket)と[**iostartnextpacket**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ntifs/nf-ntifs-iostartnextpacket)も提供します。これにより、ドライバーはを呼び出して、関連付けられているデバイスキューに i/o マネージャーを挿入するか、 [*StartIo*](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-driver_startio)ルーチンを呼び出すことができます。

そのため、ドライバーが Irp 用に独自のデバイスキューオブジェクトを設定する必要はほとんどありません (特に便利です)。 候補として考えられるのは、SCSI ポートドライバーなどのドライバーです。これは、1つのコントローラーまたはバスアダプターを介してサービスを提供する異種デバイス用に、多数の密接に結合されたクラスドライバーから受信 Irp を調整する必要があります。

つまり、ディスクアレイコントローラーのドライバーは、追加のデバイスキューオブジェクトを設定するよりも、ドライバーによって作成されたコントローラーオブジェクトを使用する可能性が高くなります。一方、アドオンバスアダプターおよびクラスドライバーのセットのドライバーは、追加のデバイスキュー。

### <a name="using-supplemental-device-queues-with-a-startio-routine"></a>StartIo ルーチンでの補足デバイスキューの使用

**Iostartpacket**と**iostartnextpacket**を呼び出すことによって、ドライバーの Dispatch ルーチンと[*DpcForIsr*](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-io_dpc_routine) (または[*customdpc*](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nc-wdm-kdeferred_routine)) ルーチンは、i/o マネージャーが作成したときに作成されたデバイスキューを使用して、 *StartIo*ルーチンへの呼び出しを同期します。ドライバーがデバイスオブジェクトを作成しました。 *StartIo*ルーチンを使用したポートドライバーの場合は、ポートドライバーの共有デバイスコントローラー/アダプターのデバイスキューにある Irp **Startpacket**と**iostartnextpacket**が挿入および削除されます。 また、高速に結合された上位レベルのクラスドライバーからの要求を保持するために、追加のデバイスキューを設定する場合は、受信 Irp を追加のデバイスキュー (通常は*StartIo*ルーチン) に "並べ替える" 必要があります。

ポートドライバーは、irp が適切なキューに挿入される前に、各 IRP が属している補足デバイスキューを特定する必要があります。 ターゲットデバイスオブジェクトへのポインターは、IRP を使用してドライバーのディスパッチルーチンに渡されます。 ドライバーは、着信 Irp の "並べ替え" で使用するためにポインターを保存する必要があります。 *StartIo*ルーチンに渡されるデバイスオブジェクトポインターは、デバイスコントローラー/アダプターを表すドライバーの独自のデバイスオブジェクトであるため、この目的には使用できないことに注意してください。

Irp をキューに入れると、ドライバーはその共有コントローラー/アダプターをプログラムして要求を実行します。 したがって、ポートドライバーは、 [**Keinsertdevicequeue**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-keinsertdevicequeue)への呼び出しによって特定のクラスドライバーのデバイスキューに IRP が格納されるまで、すべてのデバイスに対する受信要求を最初に処理することができます。

*StartIo*ルーチンを使用してすべての irp に対して独自のデバイスキューを使用することにより、基になるポートドライバーは、接続されているすべてのデバイスに対して共有デバイス (またはバス) コントローラー/アダプターを介して操作をシリアル化します。 サポートされている各デバイスの Irp を別のデバイスキューで保持することにより、このポートドライバーは、既にビジー状態のデバイスに対する Irp の処理を抑制し、共有ハードウェアを介して i/o を実行する他のすべてのデバイスの i/o スループットを向上させることができます。

ポートドライバーのディスパッチルーチンからの**Iostartpacket**への呼び出しに応答して、i/o マネージャーは、そのドライバーの*StartIo*ルーチンを直ちに呼び出すか、ポートドライバーのデバイスオブジェクトに関連付けられているデバイスキューに IRP を配置します。共有コントローラー/アダプター。

ポートドライバーは、共有デバイスコントローラー/アダプターを介してサービスを実行する異種デバイスごとに、独自の状態情報を保持する必要があります。

**補助デバイスキューを使用してクラス/ポートドライバーを設計する場合は、次の点に注意してください。**

-   ドライバーは、デバイススタックの一番上にあるデバイスオブジェクトを除き、その上にある任意のドライバーによって作成されたデバイスオブジェクトへのポインターを簡単に取得することはできません。

    仕様上、i/o マネージャーには、このようなポインターを取得するためのサポートルーチンが用意されていません。 さらに、ドライバーが読み込まれる順序により、下位のドライバーがそのデバイスを追加しているときにまだ作成されていない上位レベルのドライバーのデバイスオブジェクトのポインターを、低いドライバーで取得することはできません。

    **IoGetAttachedDeviceReference**は、ドライバーのスタック内の最上位レベルのデバイスオブジェクトへのポインターを返しますが、ドライバーは、そのスタックに対する i/o 要求のターゲットを指定するためにのみ、このポインターを使用する必要があります。 ドライバーは、デバイスオブジェクトの読み取りまたは書き込みを試行しません。

-   ドライバーは、自身のデバイススタックの一番上に要求を送信する以外は、上に重なっているドライバーによって作成されたデバイスオブジェクトへのポインターを使用することはできません。

    マルチプロセッサセーフな方法で、2つのドライバー間で1つのデバイスオブジェクト (およびそのデバイス拡張) へのアクセスを同期する方法はありません。 どちらのドライバーも、他のドライバーが現在実行している i/o 処理について、想定を行うことはできません。

クラス/ポートドライバーが密接に結合されている場合でも、各クラスドライバーは、 **IoCallDriver**を使用して irp を渡す場合にのみ、ポートドライバーのデバイスオブジェクトへのポインターを使用する必要があります。 基になるポートドライバーは、厳密に結合されたクラスドライバー (s) のデバイスに対して処理する要求について、ポートドライバーのデバイス拡張機能など、独自の状態を維持する必要があります。

### <a name="managing-supplemental-device-queues-across-driver-routines"></a>ドライバールーチン間での補足デバイスキューの管理

密接に結合されたクラスドライバーのセットに対して補足のデバイスキュー内の Irp をキューに追加するポートドライバーも、次の状況を効率的に処理する必要があります。

1.  ディスパッチルーチンによって、そのデバイスのドライバーによって作成されたデバイスキュー内の特定のデバイスの Irp が挿入されました。

2.  他のデバイスの Irp は、引き続き使用され、 **Iostartpacket**を使用してドライバーの*StartIo*ルーチンをキューに入れ、共有デバイスコントローラーを介して処理されます。

3.  デバイスコントローラーがアイドル状態になることはありませんが、ドライバーによって作成されたデバイスキューに保持されている各 IRP は、できるだけ早くドライバーの*StartIo*ルーチンのキューに入れる必要があります。

そのため、ポートドライバーが IRP を完了するたびに、ポートドライバーの*DpcForIsr*ルーチンは、特定のデバイスのドライバーの内部デバイスキューから irp を共有アダプター/コントローラーのデバイスキューに転送しようとする必要があります。後ろ

1.  *DpcForIsr*ルーチンは**Iostartnextpacket**を呼び出して、 *StartIo*ルーチンが共有デバイスコントローラーに対してキューに置かれた次の IRP の処理を開始します。

2.  *DpcForIsr*ルーチンは[**Keremovedevicequeue**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-keremovedevicequeue)を呼び出して、irp を完了しようとしているデバイスの内部デバイスキューに保持している次の irp をデキューします (存在する場合)。

3.  **Keremovedevicequeue**が NULL 以外のポインターを返す場合、 *DpcForIsr*ルーチンは、デキューされた IRP を使用して**iostartpacket**を呼び出し、共有デバイスコントローラー/アダプターをキューに入れます。 それ以外の場合、 **Keremovedevicequeue**を呼び出すと、単純にデバイスキューオブジェクトの状態が "非ビジー" にリセットされ、 *DpcForIsr*ルーチンは**iostartpacket**の呼び出しを省略します。

4.  次に、 *DpcForIsr*ルーチンは、i/o 状態ブロックをエラーで設定するか、i/o 要求を満たすことによって、ポートドライバーで i/o 処理が完了したばかりの入力 IRP を使用して[**IoCompleteRequest**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-iocompleterequest)を呼び出します。

前のシーケンスでは、Irp の内部キューを効率的に管理するために、 *DpcForIsr*ルーチンが現在の (入力) irp を完了しているデバイスを特定する必要があることに注意してください。

予備のデバイスキューに保持されている Irp をデキューする前に、その共有コントローラー/アダプターがアイドル状態になるまで、ポートドライバーが待機しようとすると、ドライバーは、他のすべてのデバイスに対して迅速にサービスを提供しつつ、大量の i/o 要求が発生したデバイスを処理する可能性があります。現在の i/o 要求は、実際にははるかに薄いものでした。

 

 




