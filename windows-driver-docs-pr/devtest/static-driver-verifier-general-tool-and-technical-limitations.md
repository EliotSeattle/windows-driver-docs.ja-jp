---
title: 静的ドライバー検証ツールの一般的なツールと技術の制限事項
description: 静的ドライバー検証ツールの一般的なツールと技術の制限事項
ms.assetid: d263dee5-2408-4772-96d7-d1895a445fab
keywords:
- 静的ドライバー検証ツールの WDK、制限事項
- StaticDV WDK、制限事項
- SDV の WDK、制限事項
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: b7e5ae2e2ac118888b298e2a9703e91847e08b99
ms.sourcegitcommit: a33b7978e22d5bb9f65ca7056f955319049a2e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/31/2019
ms.locfileid: "56560635"
---
# <a name="static-driver-verifier-general-tool-and-technical-limitations"></a>静的ドライバー検証ツールの一般的なツールと技術の制限事項


SDV は、次の一般的な制限事項があります。

-   SDV は、一度に 1 つだけのドライバーを確認し、ドライバーが完全に検証するには、これらドライバー モデルのいずれかに従う必要があります。WDM、KMDF、NDIS、または Storport します。 サポートされているドライバーに関する詳細については、次を参照してください。 [Static Driver Verifier に、ドライバーまたはライブラリがサポートしているかを決定する](determining-if-static-driver-verifier-supports-your-driver-or-library.md)します。

-   上記のカテゴリのいずれかに分類されないドライバーは、確認することができますし、分析中に失敗する可能性が高い規則で深刻な制限されます。

-   ドライバー プロジェクトのファイルおよびソース コードは、ローカル コンピューター上になければなりません。 ドライバーをリモートで確認することはできません。

-   SDV は、英語 (米国) ロケールと共にインストールされます。 その結果、文字列の書式設定などのロケールに依存する要素は、英語 (米国) のバリエーションを使用します。 この制限は、SDV が英語 (米国) 以外の Windows のローカライズ版にインストールされている場合にも存在します。

SDV[検証エンジン](verification-engine.md)にいくつかのドライバーのコードを正しく解釈されないようにする技術的な制限があります。 具体的には、検証エンジン:

-   32 ビット整数が 32 ビットに限定されることを認識しません。 その結果、オーバーフローまたはアンダー フローのエラーは検出されません。

-   そのエントリを宣言するドライバーを指しているように、**静的**キーワードが正しく処理されます。 ただし、SDV 静的エントリ ポイントが認識されていることを確認するには、必須の変更、 [Sdv map.h](sdv-map-h.md)静的関数のファイル。たとえば、静的エントリ ポイントを宣言するとします。

    ```
    static DRIVER_UNLOAD Unload;
    ```

    Sdv map.h には通常のエントリが含まれていない*楽しい\_DriverUnload*します。

    ```
    #define fun_DriverUnload Unload
    ```

    代わりに、関数名が破損することを参照してください。

    ```
      #define fun_DriverUnload sdv_static_function_Unload_1
    ```

    これは、必要なは、複数のモジュールがという名前の静的関数がある可能性があります*アンロード*します。 名前が破損する可能性のある競合を回避するためにします。

-   ドライバーのディスパッチまたはエクスポートのドライバーがドライバーのディスパッチ関数を非表示にするモジュール定義 (.def) ファイルをエクスポート、ドライバーで定義されているドライバーのコールバック関数を解釈することはできません。 この問題を回避するには、モジュール定義 (.def) ファイルの EXPORTS セクションに、ドライバーのディスパッチ関数を追加します。

-   この関数に次の参照でない場合、同じ関数のロールの種類を検出できない正常*コンパイル単位*します。

    -   関数の宣言。
    -   関数の定義。
    -   ドライバーのエントリ ポイントまたはコールバック関数を関数の割り当て。

    *コンパイル単位*は、ここでは、ソース コード ファイルの最小セットおよびその他の定義でこのソース コード ファイルに含まれるファイルのソースします。

    SDV 関数ロールの種類が検出されない、SDV は、この関数から送信されるトレースを確認できません。

    たとえば、ドライバーが定義されている場合 (または実装)、 [ *EvtDriverDeviceAdd* ](https://msdn.microsoft.com/library/windows/hardware/ff541693)ファイル mydriver.c 内の関数。 このコンパイル単位 (またはその mydriver.c が含まれています、.h ファイルには) の関数の役割の型宣言を含める必要があります、 *EvtDriverDeviceAdd*関数。

-   構造化例外処理を解釈しません。 **試用/を除く**例外がスローされない場合、ステートメント、SDV は、保護されたセクションを分析します。 式または例外ハンドラーのコードは分析されません。

    ```
    // The try/except statement
    __try 
    {
       // guarded section
    }
    __except ( expression )
    {
       // exception handler
    } 
    ```

    **して try/finally**例外がスローされない場合、分析し、保護されたセクションとし、終了ハンドラーの SDV のステートメント。

    ```
    // The try/finally statement
    __try {
       // guarded section
    }
    __finally {
       // termination handler
    }
    ```

    両方の**試用/を除く**と**して try/finally**ステートメント、SDV は無視されます、**まま**ステートメント。

    両方の**試用/を除く**と**して try/finally**ステートメント、out のジャンプを**お試しください**ブロックの分析の防止、**を除く**または**最後に**ステートメント。 書き換えのままにステートメントを使用できるようにする方法については、コンパイラの警告のトピックを参照してください。 [C6242](https://go.microsoft.com/fwlink/p/?linkid=153317)します。

-   ポインターの算術演算は無視されます。 たとえば、ポインターのインクリメントまたはデクリメントの状況を見逃します。 この制限は、false 負の値と false 肯定的な結果に可能性があります。

-   共用体は無視されます。 ほとんどの状況で、**共用体**として扱われますが、**構造体**偽陽性や偽陰性でこれになる可能性があります。

-   エラーは見直すによって解決できるとは、キャストによって発生したエラーの両方を見逃すため、キャスト操作を無視します。 たとえば、エンジンでは、文字として再キャストは、整数は、整数値をまだが前提としています。

-   だけ、関数ポインターの配列である配列を初期化します。 SDV は、警告を発行し、最初の 1000 個の要素を配列初期化子を圧縮します。 その他の配列型の最初の要素のみが初期化されます。

-   配列で初期化されるオブジェクトのコンス トラクターは呼び出されません。 たとえば、次のコード スニペットで*x* SDV は、コンス トラクターを呼び出さないため、10 に設定されません。

    ```
    class A
    {
    public:
        A() {
          x = 10;
        }

        int x;
    };

    void main()
    {
        A a[1];
    }
    ```

-   SDV は、配列を初期化するコンス トラクターの使用をサポートしていません。 たとえば、次のコード スニペットで P のコンス トラクター main 関数で正しく呼び出されるしないと、p2 の配列内の要素は初期化されません。
    ```
    class P
    {
    public:
        P() : x(0) {}
        int x;
    };

    void main()
    {
        P* p1 = new P[1];

        P p2[1] = {P()};
    }
    ```

-   SDV は、プリコンパイル済みヘッダーを無視します。 コンパイルの高速化する場合にのみ、プリコンパイル済みヘッダーを使用するドライバーは、SDV で速度が遅くなるコンパイルされます。 コンパイルが成功したのプリコンパイル済みヘッダーを使用する必要があるドライバーは、SDV にはコンパイルされません。

-   呼び出しを通じて行われる暗黙的な割り当てのいくつかの型を推論できません**RtlZeroMemory**または**NdisZeroMemory**します。 エンジンは、その型を識別できる場合にのみ、0 にメモリを初期化するためにベストエフォート分析します。 その結果、メモリを初期化するためにこれらの関数に依存するコードは、false の欠陥のあるコード パスに沿ったを起動できませんでした。

-   KMDF ドライバーへの I/O 要求の手動のディスパッチを追跡するようにするメモリ モデルをサポートしません。 エンジンは、I/O 要求を (順次または並列ディスパッチ) 用のドライバーに配信するためにフレームワークに依存するメソッドのみをサポートします。

-   比較のため、float データ型の使用はできません。 この技術的な制限では、false 負の値と false の正の結果を生成できます。

-   SDV は、仮想継承または仮想関数をサポートしていません。 SDV は、失われた場合は true。 障害につながる可能性があります、仮想関数を使用して、コード パスに続く障害を生成しません。 仮想継承は通常の継承は、false 不良または失われた場合は true。 欠陥が生じるように扱われます。

 

 





