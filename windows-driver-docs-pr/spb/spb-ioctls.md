---
title: SPB の I/O 要求
description: これらの Ioctl は、コントローラードライバーによって処理されるクライアント (周辺ドライバー) によって送信されます。
ms.assetid: 4b8ed75e-1f03-4b7a-ad9d-0dfa9b20274c
ms.date: 11/29/2017
ms.localizationpriority: medium
ms.openlocfilehash: 01199dd1e789e0791eefedbf8abfe7acd304fbb4
ms.sourcegitcommit: 2c3b8e0ea0e75b72067d2e22dc530390bc19b11e
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/02/2019
ms.locfileid: "64564962"
---
# <a name="spb-io-requests"></a>SPB の I/O 要求

「I/o 制御コードの定義」で説明されている、システムによって提供される CTL_CODE マクロは、Spb. h の IOCTL_SPB_ * 制御コードを定義するために使用されます。

|トピック | 説明|
|------|:----------------|
|[IOCTL_SPB_EXECUTE_SEQUENCE](#ioctl_spb_execute_sequence) | IOCTL_SPB_EXECUTE_SEQUENCE i/o 制御コードを使用すると、SPB コントローラードライバーのクライアント (周辺ドライバー) は、1つの i/o 要求で1つのアトミック操作として一連の転送 (読み取りと書き込み) を実行できます。 バス上の指定されたデバイスは、シーケンス内のすべての転送のターゲットです。|
|[IOCTL_SPB_FULL_DUPLEX](#ioctl_spb_full_duplex-control-code) | IOCTL_SPB_FULL_DUPLEX 制御コードは、全二重の i/o 操作を要求するために、クライアント (周辺機器ドライバー) によって使用されます。 全二重 i/o 操作は、データの読み取りと書き込みを同時に実行できる SPI などのバスのコントローラーによってサポートされます。|
|[IOCTL_SPB_LOCK_CONNECTION](#ioctl_spb_lock_connection-control-code) | IOCTL_SPB_LOCK_CONNECTION 制御コードは、別のクライアントと共有されている SPB 接続ターゲットデバイスの接続ロックを取得するために、クライアント (周辺機器ドライバー) によって使用されます。 クライアントが接続ロックを保持している間、このクライアントはデバイスに排他的にアクセスできます。|
|[IOCTL_SPB_LOCK_CONTROLLER](#ioctl_spb_lock_controller-control-code) | IOCTL_SPB_LOCK_CONTROLLER 制御コードは、クライアント (周辺ドライバー) が SPB コントローラーをロックするために使用されます。 コントローラーがロックされている間、クライアントは、そのロックに対して指定されたターゲットデバイスにアクセスするために、バスを排他的に使用します。
|[IOCTL_SPB_UNLOCK_CONNECTION](#ioctl_spb_unlock_connection-control-code) | I/o 制御コードは、別のクライアントと共有されている SPB 接続ターゲットデバイスの接続ロックを解放するために、クライアント (周辺機器ドライバー) によって使用されます。 クライアントは、デバイスへの排他アクセスを取得するために、以前に IOCTL_SPB_LOCK_CONNECTION 要求を送信しました。|
|[IOCTL_SPB_UNLOCK_CONTROLLER](#ioctl_spb_unlock_controller-control-code) |IOCTL_SPB_UNLOCK_CONTROLLER i/o 制御コードは、SPB コントローラーのロックを解除するためにクライアント (周辺ドライバー) によって使用されます。 クライアントは、バスを排他的に使用してバス上のターゲットデバイスにアクセスするようにコントローラーをロックしていました。|

## <a name="ioctl_spb_execute_sequence"></a>IOCTL_SPB_EXECUTE_SEQUENCE

IOCTL_SPB_EXECUTE_SEQUENCE i/o 制御コードを使用すると、SPB コントローラードライバーのクライアント (周辺ドライバー) は、1つの i/o 要求で1つのアトミック操作として一連の転送 (読み取りと書き込み) を実行できます。 バス上の指定されたデバイスは、シーケンス内のすべての転送のターゲットです。

固定長転送のシーケンスを1つのアトミックな操作として指定することにより、IOCTL_SPB_EXECUTE_SEQUENCE i/o 制御要求によって、コントローラードライバーは i/o 転送を最適化し、パフォーマンスを向上させることができます。

クライアントは、この i/o 制御要求をターゲットデバイスのファイルオブジェクトに送信します。

SPB コントローラードライバーは、i/o 転送シーケンスのバス転送を実行する EvtSpbControllerIoSequence コールバック関数を登録します。 SPB フレームワーク拡張 (SpbCx) は、この関数を呼び出して、IOCTL_SPB_EXECUTE_SEQUENCE 要求を SPB コントローラードライバーに渡して処理します。

### <a name="input-buffer"></a>入力バッファー

入力バッファーは SPB_TRANSFER_LIST 構造体であり、クライアントのデータバッファーへのポインターの一覧が含まれています。 この一覧には、i/o 転送シーケンス内の各転送 (読み取りまたは書き込み) 用のデータバッファーが含まれています。

### <a name="input-buffer-length"></a>入力バッファーの長さ

SPB_TRANSFER_LIST 構造体のサイズ。

### <a name="status-block"></a>ステータス ブロック

操作が成功した場合、コントローラードライバーは状態メンバーを STATUS_SUCCESS に設定し、情報メンバーをシーケンス中に転送された合計バイト数に設定します。

この操作はさまざまな理由で失敗する可能性があります。これには、リソースの不足、無効なクライアント入力、デバイスの誤動作などがあります。

コントローラードライバーが i/o 要求の処理を開始しても、シーケンスの転送中にエラーが発生した場合 (たとえば、転送を拒否するためにターゲットデバイスが NACK に通知する場合)、コントローラードライバーはシーケンス内の残りの転送を中止します。 次に、ドライバーは、完了ステータスを STATUS_SUCCESS に設定し、エラーが発生する前に正常に転送されたバイト数に情報メンバーを設定して、要求を完了します。

## <a name="ioctl_spb_full_duplex-control-code"></a>IOCTL_SPB_FULL_DUPLEX 制御コード

IOCTL_SPB_FULL_DUPLEX 制御コードは、全二重の i/o 操作を要求するために、クライアント (周辺機器ドライバー) によって使用されます。 全二重 i/o 操作は、データの読み取りと書き込みを同時に実行できる SPI などのバスのコントローラーによってサポートされます。
「I/o 制御コードの定義」で説明されている、システムによって提供される CTL_CODE マクロは、次のように IOCTL_SPB_FULL_DUPLEX を定義するために使用されます。

バス上のデバイスのユーザーモードドライバーまたはカーネルモードドライバーは、この i/o 制御要求をターゲットデバイスのファイルオブジェクトに送信します。

この IOCTL は、データの読み取りと書き込みを同時に行うことができる、SPI などの、バスの SPB コントローラードライバーによってのみサポートされます。

全二重転送の書き込みバッファーと読み取りバッファーは、SPB_TRANSFER_LIST 構造体によって記述されます。 この構造体は、次の形式を使用する必要があります。

* SPB_TRANSFER_LIST_ENTRY 構造体の配列には、ちょうど2つの要素が含まれています。 最初の要素は、書き込みバッファー (Direction = Spbtransferdirection Todevice) を記述します。 2番目の要素は、読み取りバッファー (Direction = Spbtransferdirection Fromdevice) を記述します。
* 2つの SPB_TRANSFER_LIST_ENTRY 構造体の DelayInUs メンバーは0である必要があります。 書き込みバッファーと読み取りバッファーのバッファー形式は、次のいずれかになります。

  * SpbTransferBufferFormatSimple
  * SpbTransferBufferFormatList
  * SpbTransferBufferFormatSimpleNonPaged
  * SpbTransferBufferFormatMdl

  上記の一覧の最後の2つの形式は、カーネルモードのクライアントでのみ使用できます。 書き込みバッファーと読み取りバッファーの形式は同じである必要はありません。 これらのバッファー形式の詳細については、「SPB_TRANSFER_BUFFER_FORMAT」を参照してください。

操作が正常に行われると、情報メンバーが書き込みバッファーのサイズと読み取りバッファーのサイズの合計よりも小さい値に設定されることがあります。これは、要求が取り消された場合、または操作が書き込みバッファーの完全な内容をデバイスに書き込めない場合に発生する可能性があります。、または、デバイスから読み取られたデータを読み取りバッファーに完全に入力します。

書き込みバッファーサイズと読み取りバッファーサイズは同じである必要はありません。 書き込みバッファーが読み取りバッファーより大きい場合、読み取りバッファーがいっぱいになると、書き込みバッファーからのデータの書き込みが続行されます。 読み取りバッファーが書き込みバッファーよりも大きい場合、書き込みバッファーが空になった後も、読み取りバッファーがいっぱいになります。

SPB コントローラードライバーが EvtSpbControllerIoOther コールバック関数を登録する場合、SPB フレームワーク拡張 (SpbCx) はこの関数を呼び出して、IOCTL_SPB_FULL_DUPLEX 要求を処理のために SPB コントローラードライバーに渡します。 SpbCx では、パラメーターチェック、転送リストの検証、または IOCTL_SPB_FULL_DUPLEX 要求のその他の処理は実行されません。

SPB コントローラードライバーがこの IOCTL のサポートを実装する方法の詳細については、「IOCTL_SPB_FULL_DUPLEX 要求の処理」を参照してください。

### <a name="input-buffer"></a>入力バッファー

クライアントの入力データバッファーと出力データバッファーへのポインターを格納する SPB_TRANSFER_LIST 構造体へのポインター。 この構造体には、厳密に2つの要素から成る転送配列が含まれます。 最初の要素は、デバイスに書き込むデータを格納するバッファーを記述します。 2番目の要素は、デバイスから読み取られたデータを保持するために使用されるバッファーを表します。
SPB_TRANSFER_LIST 構造体を使用してバッファーを記述するカスタム i/o 制御 (IOCTL) 要求を SPB コントローラードライバーが実装する方法の詳細については、「SPB_TRANSFER_LIST 構造体をカスタム Ioctl に使用する」を参照してください。

### <a name="input-buffer-length"></a>入力バッファーの長さ

SPB_TRANSFER_LIST 構造体のサイズ。

### <a name="status-block"></a>ステータス ブロック

操作が成功した場合、コントローラードライバーは状態メンバーを STATUS_SUCCESS に設定し、全二重操作中に、転送されたバイト数の合計 (読み取ったバイト数と書き込みバイト数) に情報メンバーを設定します。

この操作はさまざまな理由で失敗する可能性があります。これには、リソースの不足、無効なクライアント入力、デバイスの誤動作などがあります。

## <a name="ioctl_spb_lock_connection-control-code"></a>IOCTL_SPB_LOCK_CONNECTION 制御コード

IOCTL_SPB_LOCK_CONNECTION 制御コードは、別のクライアントと共有されている SPB 接続ターゲットデバイスの接続ロックを取得するために、クライアント (周辺機器ドライバー) によって使用されます。 クライアントが接続ロックを保持している間、このクライアントはデバイスに排他的にアクセスできます。
「I/o 制御コードの定義」で説明されている、システムによって提供される CTL_CODE マクロは、次のように IOCTL_SPB_LOCK_CONNECTION を定義するために使用されます。

IOCTL_SPB_LOCK_CONNECTION 要求と IOCTL_SPB_UNLOCK_CONNECTION 要求は、単純な周辺機器バスに接続されているターゲットデバイスの接続ロックを取得し、解放します。 ほとんどのクライアントは、これらの i/o 制御要求を使用しません。 これらの要求は、2つのクライアントが同じターゲットデバイスへのアクセスを共有している場合にのみ使用されます。 詳細については、「SPB の接続ロック」を参照してください。

2つのクライアントは、同じターゲットデバイスに対して別々の論理接続を開き、いずれかのクライアントでデバイスへの排他的アクセスが必要な場合に、接続ロックを使用できます。 1つのクライアントがロックを保持している場合、2番目のクライアントからのデバイスへの i/o 要求は、最初のクライアントがロックを解放するまで自動的に遅延されます。

クライアントは、ターゲットデバイスに接続ロックを保持し、SPB コントローラーでコントローラーロックを同時に保持できます。 IOCTL_SPB_LOCK_CONTROLLER 要求と IOCTL_SPB_UNLOCK_CONTROLLER 要求は、コントローラーロックを取得して解放します。 クライアントは、コントローラーロックを取得する前に接続ロックを取得する必要があります。接続ロックを解除する前に、コントローラーロックを解放する必要があります。 クライアントは、コントローラーロックを使用して、1つのアトミックバス操作として、順序付けされた一連のバス転送 (読み取りおよび書き込み操作) を実行します。 詳細については、「i/o 転送シーケンス」を参照してください。

接続がデバイスでロックされている間に IRP_MJ_CLEANUP 要求がターゲットデバイスに送信されると、接続ロックは自動的に終了します。 クライアントがデバイスへのファイルハンドルを閉じると、クリーンアップ要求がターゲットデバイスに送信されます。

### <a name="status-block"></a>ステータス ブロック

操作が成功した場合、Status メンバーは STATUS_SUCCESS に設定されます。

操作が失敗した場合、Status メンバーは適切なエラー状態コードに設定されます。

クライアントが既にターゲットデバイスの接続ロックを保持しているか、または SPB コントローラーのコントローラーロックを保持している場合、この操作は Status = STATUS_INVALID_DEVICE_REQUEST で失敗します。 この操作は、リソース不足、無効なクライアント入力、デバイスの誤動作など、他の理由で失敗する可能性があります。

## <a name="ioctl_spb_lock_controller-control-code"></a>IOCTL_SPB_LOCK_CONTROLLER 制御コード

IOCTL_SPB_LOCK_CONTROLLER 制御コードは、クライアント (周辺ドライバー) が SPB コントローラーをロックするために使用されます。 コントローラーがロックされている間、クライアントは、そのロックに対して指定されたターゲットデバイスにアクセスするために、バスを排他的に使用します。
「I/o 制御コードの定義」で説明されている、システムによって提供される CTL_CODE マクロは、次のように IOCTL_SPB_LOCK_CONTROLLER を定義するために使用されます。

ターゲットデバイスにアクセスするためにバスを排他的に使用するために、クライアント (周辺ドライバー) は、この IOCTL をターゲットのファイルオブジェクトに送信します。 この IOCTL が完了すると、コントローラーはロックされ、バス上のすべての i/o 転送 (読み取りまたは書き込み) が、指定されたターゲットにアクセスします。 転送の間、コントローラーはターゲットデバイスを選択したままにしますが、クロックは停止します。

コントローラーは、クライアントが IOCTL_SPB_UNLOCK_CONTROLLER 要求を送信してコントローラーのロックを解除するまでロックされたままになります。 ターゲットデバイスとの間のクライアントの転送シーケンスが完了すると、クライアントはコントローラーのロックを解除して、コントローラーがバス上の他のターゲットに対する i/o 要求を処理できるようにする必要があります。

コントローラーがターゲットでロックされている間に IRP_MJ_CLEANUP 要求がターゲットデバイスに送信されると、ロックは自動的に終了します。 クライアントがターゲットへのハンドルを閉じたときに、クリーンアップ要求がターゲットに送信されます。

IOCTL_SPB_LOCK_CONTROLLER と IOCTL_SPB_UNLOCK_CONTROLLER の要求をサポートするために SPB コントローラーは必要ありません。また、周辺機器ドライバーは、サポートされていることを前提としていません。

SPB コントローラードライバーが Evtspbcontroller ロックのコールバック関数を登録する場合、SPB フレームワーク拡張 (SpbCx) はこの関数を呼び出して、IOCTL_SPB_LOCK_CONTROLLER 要求を SPB コントローラードライバーに渡して処理します。

### <a name="status-block"></a>ステータス ブロック

操作が成功した場合、Status メンバーは STATUS_SUCCESS に設定されます。
この IOCTL は、排他アクセスモードで動作するようにコントローラーを構成できないなど、さまざまな理由でエラー状態を返すことがあります。 このモードでは、コントローラーはターゲットデバイスを選択したままにして、バス上のすべての i/o 転送に対して排他的なターゲットにします。 ロックが解除されるまで、コントローラーはこのモードのままになります。

## <a name="ioctl_spb_unlock_connection-control-code"></a>IOCTL_SPB_UNLOCK_CONNECTION 制御コード

IOCTL_SPB_UNLOCK_CONNECTION i/o 制御コードは、別のクライアントと共有されている SPB 接続ターゲットデバイスの接続ロックを解放するために、クライアント (周辺機器ドライバー) によって使用されます。 クライアントは、デバイスへの排他アクセスを取得するために、以前に IOCTL_SPB_LOCK_CONNECTION 要求を送信しました。

IOCTL_SPB_LOCK_CONNECTION 要求と IOCTL_SPB_UNLOCK_CONNECTION 要求は、単純な周辺機器バスに接続されているターゲットデバイスの接続ロックを取得し、解放します。 ほとんどのクライアントは、これらの i/o 制御要求を使用しません。 これらの要求は、2つのクライアントが同じターゲットデバイスへのアクセスを共有している場合にのみ使用されます。 詳細については、「SPB の接続ロック」を参照してください。

クライアント (周辺ドライバー) がバス上のターゲットデバイスに IOCTL_SPB_LOCK_CONNECTION 要求を送信し、要求が正常に完了すると、クライアントが IOCTL_SPB_UNLOCK_CONNECTION 要求を送信して、接続.

クライアントがデバイスへの排他的アクセスを必要としなくなったときに、クライアントは IOCTL_SPB_UNLOCK_CONNECTION 要求を送信して、接続ロックをターゲットデバイスに解放します。 もう一方のクライアントがデバイスにアクセスできるように、接続のロックを解除する必要があります。

### <a name="status-block"></a>ステータス ブロック

操作が成功した場合、Status メンバーは STATUS_SUCCESS に設定されます。

操作が失敗した場合、Status メンバーは適切なエラー状態コードに設定されます。 クライアントがターゲットデバイスに接続ロックを保持していない場合、またはクライアントが SPB コントローラーの接続ロックを保持している場合、この操作は Status = STATUS_INVALID_DEVICE_REQUEST で失敗します。 この操作は、リソース不足、無効なクライアント入力、デバイスの誤動作など、他の理由で失敗する可能性があります。

## <a name="ioctl_spb_unlock_controller-control-code"></a>IOCTL_SPB_UNLOCK_CONTROLLER 制御コード

IOCTL_SPB_UNLOCK_CONTROLLER i/o 制御コードは、SPB コントローラーのロックを解除するためにクライアント (周辺ドライバー) によって使用されます。 クライアントは、バスを排他的に使用してバス上のターゲットデバイスにアクセスするようにコントローラーをロックしていました。

クライアント (周辺ドライバー) がバス上のターゲットデバイスに IOCTL_SPB_LOCK_CONTROLLER i/o 制御要求を送信した後、コントローラーは、クライアントが IOCTL_SPB_UNLOCK_CONTROLLER i/o 制御要求を送信してコントローラーのロックを解除するまでロックされたままになります。 クライアントは、これらの i/o 制御要求をターゲットデバイスのファイルオブジェクトに送信します。

クライアントは、バスで転送シーケンスを完了し、ターゲットデバイスを解放する必要がある場合に、IOCTL_SPB_UNLOCK_CONTROLLER 要求を送信します。 バス上の他のターゲットに対する i/o 要求を処理できるように、コントローラーのロックを解除する必要があります。

IOCTL_SPB_LOCK_CONTROLLER と IOCTL_SPB_UNLOCK_CONTROLLER の要求をサポートするために SPB コントローラーは必要ありません。また、周辺機器ドライバーは、サポートされていることを前提としていません。

SPB フレームワーク拡張 (SpbCx) は、SPB コントローラードライバーのオプションの EvtspbIOCTL_SPB_LOCK_CONTROLLER Unlock コールバック関数を呼び出して、処理のために SPB コントローラードライバーに要求を渡します。

## <a name="status-block"></a>ステータス ブロック

操作が成功した場合、Status メンバーは STATUS_SUCCESS に設定されます。
この IOCTL は、指定されたターゲットへの排他アクセスのためにコントローラーがロックされていないクライアントによって送信された場合にのみ失敗します。
