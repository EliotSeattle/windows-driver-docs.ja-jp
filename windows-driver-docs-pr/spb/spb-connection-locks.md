---
title: SPB 接続のロック
description: 接続ロックは、2つのクライアントが、単純な周辺機器バス (SPB) 上のターゲット周辺機器へのアクセスを共有できるようにする場合に便利です。
ms.assetid: 073D9854-0F51-4518-A22B-0A0546694E30
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 91beea7673db12540407738cd4f3e8a8dc360ac9
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72839627"
---
# <a name="spb-connection-locks"></a>SPB 接続のロック


接続ロックは、2つのクライアントが、[単純な周辺機器バス](https://docs.microsoft.com/previous-versions/hh450903(v=vs.85))(SPB) 上のターゲット周辺機器へのアクセスを共有できるようにする場合に便利です。 どちらのクライアントも、同じターゲットデバイスへの論理接続を開き、クライアントが一連の i/o 操作を実行するためにデバイスへの排他的アクセスを必要とする場合に、接続ロックを使用できます。 1つのクライアントが接続ロックを保持している場合、デバイスにアクセスする2番目のクライアントからの要求は、最初のクライアントがロックを解放するまで自動的に遅延されます。

クライアントは、 [**ioctl\_spb\_ロック\_接続**](https://msdn.microsoft.com/library/windows/hardware/jj819324)および[**ioctl\_spb**](https://msdn.microsoft.com/library/windows/hardware/jj819325)を使用して\_接続要求のロックを解除し、spb 上のターゲットデバイスの接続ロックを取得して解放します。\_ クライアントは、これらの i/o 制御 (IOCTL) 要求をデバイスのファイルオブジェクトに送信します。

SPB に接続されている周辺機器のドライバーは、通常、ユーザーモードドライバーフレームワーク (UMDF) ドライバーまたはカーネルモードドライバーフレームワーク (KMDF) ドライバーのいずれかです。 UMDF 接続された周辺機器に IOCTL 要求を送信するために、UMDF ドライバーは[**IWDFIoRequest:: send**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wudfddi/nf-wudfddi-iwdfiorequest-send)などのメソッドを呼び出します。 KMDF ドライバーは、 [**Wdfiotargetsendioctlsynchronously**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdfiotarget/nf-wdfiotarget-wdfiotargetsendioctlsynchronously)のメソッドを同期的に呼び出します。

通常、接続ロックは不要です。 ほとんどのクライアントドライバーは、常に SPB 上のターゲットデバイスに排他的にアクセスします。 接続ロックは、2つのクライアントが同じターゲットデバイスへのアクセスを共有する必要があり、1つまたは両方のクライアントが一連の i/o 操作のためにデバイスに排他的にアクセスする必要がある場合にのみ必要です。

既定では、2つのクライアントがターゲットデバイスを共有する場合、 [SPB フレームワーク拡張](https://docs.microsoft.com/windows-hardware/drivers/spb/spb-framework-extension)(spbcx) は、spbcx 要求キューに到着した順序に従って、デバイスの i/o 要求をシリアル化します。 接続ロックは、要求の既定の順序を上書きします。 1つのクライアントが接続ロックを取得した後、SpbCx は、最初のクライアントがロックを解放するまで、2番目のクライアントから受信するバック i/o 要求を保持します。

現在の SpbCx の実装では、接続ロックの主な用途は、ターゲットデバイスのクライアントドライバーが、ACPI ドライバーである Acpi ドライバーを使用してデバイスへのアクセスを共有できるようにすることです。 Acpi は、ハードウェアプラットフォームの ACPI ファームウェアに代わって特定のコアリソースデバイスを管理する、システム提供のドライバーです。 たとえば、チップ上のシステムを使用するプラットフォーム (SoC) には、Acpi とクライアントドライバーの両方によってアクセスされる電源管理統合回線 (PMIC) も含まれる場合があります。

クライアントドライバーは、ターゲットデバイスへの排他的アクセスを必要とする i/o 操作に対して、接続ロックが必要かどうかを判断する役割を担います。 ドライバーが、一部のハードウェアプラットフォームまたはプラットフォーム構成では接続ロックを必要としているが、それ以外の場合は、接続ロックを使用するかどうかを判断するためのドライバー固有のメカニズムに同意する必要があります。 通常、接続ロックを使用するかどうかに関する情報は、プラットフォームのファームウェアに含まれています。 たとえば、デバイスの ACPI リソース記述子のベンダー定義情報ブロックには、ドライバーがデバイスを Acpi と共有するかどうかを示すフラグビットを含めることができます。

## <a name="connection-lock-example"></a>接続ロックの例


一般的な接続ロックの使用方法は、アトミックの読み取り/書き込み操作を実装することです。 2つのクライアントが、単純な周辺機器バス (SPB) 上の同じターゲットデバイスへのアクセスを共有する場合、どちらのクライアントも接続ロックを使用して読み取り操作と書き込み操作を1つのアトミックの読み取り/書き込み操作にマージできます。 接続ロックは、他のクライアントが読み取り操作と書き込み操作の間にターゲットデバイスにアクセスできないようにします。

次の一覧では、クライアントが SPB に接続されたターゲットデバイスに送信して、デバイス上で読み取り/変更/書き込み操作を実行することがある、一連の i/o 要求について説明します。

1.  [**IOCTL\_SPB\_ロック\_接続**](https://msdn.microsoft.com/library/windows/hardware/jj819324)–ターゲットデバイスの接続ロックを取得します。
2.  [**IRP\_MJ\_read**](https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mj-read) –クライアントがデータを解釈および変更できるように、デバイスアドレスからデータのブロックを読み取ります。
3.  [**IRP\_MJ\_書き込み**](https://docs.microsoft.com/windows-hardware/drivers/kernel/irp-mj-write)–変更されたデータブロックをデバイスアドレスに書き込みます。
4.  [**IOCTL\_SPB\_\_接続のロックを解除**](https://msdn.microsoft.com/library/windows/hardware/jj819325)する–ターゲットデバイスの接続ロックを解除します。

上記の一覧は、1つのデバイス機能を実装する単純なデバイスに適している場合があります。

ただし、より複雑なデバイスでは、複数のデバイス機能を実装する場合があります。 このデバイスには、データ転送の開始時にクライアントが読み込む関数アドレスレジスタが含まれている場合があります。 このデバイスの場合、 [ **\_シーケンス要求を実行\_IOCTL\_SPB**](https://msdn.microsoft.com/library/windows/hardware/hh450857)は、関数アドレスレジスタの読み込みと、次のデータ転送を1つのアトミックバス操作に組み合わせることができます。 詳細については、[アトミックバス操作](https://docs.microsoft.com/windows-hardware/drivers/spb/atomic-bus-operations)の例 I ² C デバイスの説明を参照してください。

## <a name="comparison-with-controller-locks"></a>コントローラーロックとの比較


クライアントは、接続ロックを使用してターゲットデバイスへの排他アクセスを取得しますが、接続ロックによって、バス上の他のデバイスとの間のデータ転送が妨げられることはありません。

アトミックバス操作として一連のデータ転送を実行するには、クライアントは通常、 [**IOCTL\_SPB**](https://msdn.microsoft.com/library/windows/hardware/hh450857)を使用して\_シーケンス要求を実行\_ます。 アトミックバス操作を実行する一般的な方法は、コントローラーロックを使用することです。 クライアントは、 [ **\_ロック\_コントローラー**](https://msdn.microsoft.com/library/windows/hardware/hh450858)および[**ioctl\_spb**](https://msdn.microsoft.com/library/windows/hardware/hh450859)に ioctl\_spb を送信し、コントローラーロックの取得と解放に\_コントローラーの要求をロック解除\_ます。

コントローラーロックは、接続ロックとは異なります。 コントローラーロックを使用すると、バス上のターゲットデバイスとの間で行われる一連の i/o 転送が、単一のアトミックバス操作として実行されます。 コントローラーロックが有効になっている間、バス上の他のデバイスとの間の転送は、コントローラーロックが解除されるまで遅延されます。 詳細については、「 [Atomic Bus の操作](https://docs.microsoft.com/windows-hardware/drivers/spb/atomic-bus-operations)」を参照してください。

**注**  一部の実装では、接続ロックが副作用として、バス上の他のデバイスへの転送を妨げる可能性があることに注意してください。 ただし、この動作は実装に依存し、クライアントドライバーがそれに依存しないようにする必要があります。 一方、コントローラーロックを使用すると、別のクライアントがコントローラーロックを保持しているクライアントと同じターゲットデバイスにアクセスするのを防ぐことができ、クライアントはこの動作に安全に依存できます。

 

クライアントは、ターゲットデバイスで i/o 操作のセットを実行する前に、接続ロックとコントローラーロックの両方を取得する必要がある場合があります。 接続ロックは、同じターゲットデバイスへのアクセスを共有する2台目のクライアントがデバイスで i/o 操作を実行できないようにします。また、コントローラーロックは、バス上の他のデバイスのクライアントがこれらの他のデバイスで i/o 操作を実行できないようにします。 (これらのロックが保持されている間に発生しない i/o 操作は、ロックが解放されるまで遅延されます)。

クライアントが SPB 上のターゲットデバイスに対して接続ロックとコントローラーロックの両方を取得する場合、クライアントはコントローラーロックを取得する前に接続ロックを取得する必要があり、接続ロックを解除する前にコントローラーロックを解放する必要があります。 クライアントは、接続ロックを取得した後、必要に応じて、クライアントが接続ロックを解放する前に必要な回数だけコントローラーロックを取得して解放できます。

接続ロックの入れ子になった取得は無効です。 クライアントが接続ロックを取得した後は、クライアントが最初にロックを解放するまで、クライアントはロックを再び取得しないようにする必要があります。 同様に、コントローラーロックの入れ子になった取得は許可されません。

 

 




