---
title: アトミック バス操作
description: Sp B に接続されている周辺機器の特定のハードウェア機能を使用するには、SPB コント ローラー (つまり、周辺ドライバー) のクライアントは、バスのアトミック操作として、デバイスとのデータ転送のシーケンスを実行する必要があります。
ms.assetid: F8CD670F-C817-40BF-AF4B-5F3839E46EFB
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 7d71bd1573a871c2e5f9effc969e7b4d000a9ce0
ms.sourcegitcommit: a33b7978e22d5bb9f65ca7056f955319049a2e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/31/2019
ms.locfileid: "56571811"
---
# <a name="atomic-bus-operations"></a>アトミック バス操作


Sp B に接続されている周辺機器の特定のハードウェア機能を使用するには、SPB コント ローラー (つまり、周辺ドライバー) のクライアントは、バスのアトミック操作として、デバイスとのデータ転送のシーケンスを実行する必要があります。 転送シーケンスは、他のクライアント データを転送できますなしに、またはデバイスからバス上、シーケンスが終了するまでためアトミックです。

現状、バスのアトミック操作を送信する転送シーケンスを実行するクライアントの一般的な方法、 [ **IOCTL\_SPB\_EXECUTE\_シーケンス**](https://msdn.microsoft.com/library/windows/hardware/hh450857)を要求しますターゲット デバイス。 この要求では、クライアントは、シンプルなリストの読み取りし、書き込み転送シーケンスを指定します。 任意の長さの一覧ができます。 順番を示されているとそれぞれの読み取りまたは書き込みバイト数の任意の数を転送できる、読み取りと書き込みが実行されます。 ほとんどの SPB コント ローラー サポート**IOCTL\_SPB\_EXECUTE\_シーケンス**要求。

## <a name="spb-controller-locks"></a>SPB コント ローラーのロック


アトミック転送シーケンスを実行するあまり一般的な方法は、SPB コント ローラーのロックを使用します。 クライアントが送信、 [ **IOCTL\_SPB\_ロック\_コント ローラー** ](https://msdn.microsoft.com/library/windows/hardware/hh450858) 、ロックの取得を要求し、 [ **IOCTL\_SPB\_UNLOCK\_コント ローラー** ](https://msdn.microsoft.com/library/windows/hardware/hh450859)ロックを解除する要求。 クライアントがコント ローラーのロック、単純な読み取りと書き込みの任意のシーケンスを保持する場合 ([**IRP\_MJ\_読み取り**](https://msdn.microsoft.com/library/windows/hardware/ff550794)と[ **IRP\_MJ\_書き込み**](https://msdn.microsoft.com/library/windows/hardware/ff550819)) クライアントがデバイスに送信する要求は、バスに対するアトミック操作として実行されます。

SPB に接続されているほとんどの周辺機器にコント ローラーのロックが必要としないと、ほとんど SPB コント ローラーのドライバーはこれらのロックのサポートを実装していません。 ただし、いくつかのクライアントは、コント ローラーのロックを使用して、通常とは異なる機能を持つデバイスにアクセスする必要があります。

たとえば、デバイスは、バスにアトミックである読み取り/変更/書き込み操作でのみアクセスできるデバイス関数を実装する可能性があります。 このような操作を実行するには、クライアントは、(で示されている順序) の次の 4 つの I/O 要求を送信します。

1.  **IOCTL\_SPB\_ロック\_コント ローラー** – コント ローラーのロックを取得します。
2.  **IRP\_MJ\_読み取り**– 対象となるデバイスからのデータのブロックを読み取ります。
3.  **IRP\_MJ\_書き込み**– デバイスに変更されたデータを書き込みます。
4.  **IOCTL\_SPB\_UNLOCK\_コント ローラー** – コント ローラーのロックを解放します。

上記のリストの読み取り操作の後は、クライアントは、デバイスから読み取られた、デバイスに書き戻す前に、データを変更するデータを解釈します。

ただし、ほとんどの sp B に接続されたデバイスでは、コント ローラーのロックが必要な機能がありません。 アトミックを必要とするほとんどのデバイスの操作のバスの[ **IOCTL\_SPB\_EXECUTE\_シーケンス**](https://msdn.microsoft.com/library/windows/hardware/hh450857)要求で十分です。

SPB 接続ロック SPB コント ローラーのロックを混同しないでください。 2 つのクライアントが同じ SPB に接続されている周辺機器のデバイスへのアクセスを共有する特殊な場合は、いずれかのクライアントは、一時的にデバイスへの排他アクセスを取得する接続ロックを使用できます。 詳細については、[SPB 接続ロック](https://msdn.microsoft.com/library/windows/hardware/jj819326)を参照してください。

## <a name="hardware-bus-signals"></a>ハードウェア バス信号


処理するために、 [ **IOCTL\_SPB\_EXECUTE\_シーケンス**](https://msdn.microsoft.com/library/windows/hardware/hh450857)要求、SPB のコント ローラー ドライバーが、適切なを生成するコント ローラーのハードウェアを構成します転送シーケンス中に、バスに通知します。 バスに接続されている周辺機器のデバイスには、バスのアトミック操作が進行中の場合を検出するためにこれらのシグナルが依存しています。 ハードウェアのセット SPB のコント ローラーを使用 bus のアトミック操作は、バスの種類によって異なります。 転送シーケンスを実行することを通知します。

I²C bus の場合は、コント ローラーは、バス上の開始ビットを送信して、シーケンスを開始し、ストップ ビットを送信してシーケンスを終了します。 開始と停止のビット間と、デバイスからのデータ転送のシーケンスは、バスの単一のアトミック操作として実行されます。 シーケンスの最後の転送を除く I²C 再起動操作 (の前にストップ ビット、繰り返しの開始ビット) の各転送が続きます。

SPI バスは、コント ローラーは、チップの選択行が、ターゲット デバイスをアサートすることで、シーケンスを開始し、deasserting チップ選択行によって、シーケンスを終了します。 バス経由でデータ転送のシーケンス中に継続的にアサート チップ選択線を保つことによって、転送は、バスの単一のアトミック操作として実行されます。

## <a name="an-example-ic-device"></a>例 I²C デバイス


I²C バス上の一般的な周辺機器は、いくつかのデバイスの内部関数を実装できます。 これらの関数にアクセスするクライアントが使用可能性があります[ **IOCTL\_SPB\_EXECUTE\_シーケンス**](https://msdn.microsoft.com/library/windows/hardware/hh450857)要求。

たとえば、I²C 周辺機器のデバイスには、次の 2 つの内部レジスタが含まれます。

-   A*関数アドレス登録*クライアント書き込みにアクセスするデバイスの機能の内部アドレス。
-   A*データ レジスタ*クライアントがからデータを読み取るまたは指定された関数のアドレスにデータを書き込むを使用します。

この例では I²C 周辺機器は、関数アドレスは、関数アドレス レジスタに読み込む開始ビット後、デバイスに書き込まれる最初のバイトを解釈します。 (ストップ ビットを示す) ように、シーケンスが終了する前に、またはデバイスからの移動、追加のバイトは、デバイスによってデータ レジスタから転送されるデータとして扱われます。

書き込み操作を実行するクライアントは、書き込みを送信します ([**IRP\_MJ\_書き込み**](https://msdn.microsoft.com/library/windows/hardware/ff550819)) 書き込みバッファーの最初のバイトの関数のアドレスと、残りの要求バッファー内のバイトは、関数のアドレスに書き込まれるデータです。

デバイスからの読み取りより複雑です。 バス上でこの関数のアドレスを自動的にリセットする「高速の読み取り」機能が既定値はビットが停止するときは、0 に登録の例がサポートする I²C デバイスが検出されたことを想定しています。 この機能により、クライアントからデータを読み取る関数アドレス 0 関数アドレス登録を作成することがなく。 この機能は、ほとんど読み取りは、関数アドレス 0 から、比較的短い場合に特に、読み取り操作、デバイスの速度を向上させることができます。

ただし、0 以外の関数のアドレスからのデータ ブロックを読み取るクライアントもする必要がありますバイトを書き込む、関数アドレス登録データ レジスタからデータ ブロックを読み取る前に。 クライアントは、これらの書き込みを実行し、読み取りから関数アドレスへの書き込みを登録した後、ストップ ビットを送信し、データ レジスタからの読み取り前に、バス コント ローラーを防ぐために、バスのアトミック操作として転送する必要があります。 それ以外の場合、ストップ ビットは 0 以外の関数のアドレスからの代わりに関数アドレス 0 から読み取るデータが発生します。

次の一覧には、一連のデバイスでゼロ以外の関数のアドレスにあるデータの読み取り/変更/書き込み操作を実行するクライアントがこの例では I²C デバイスに送信する I/O 要求がについて説明します。

1.  **IOCTL\_SPB\_EXECUTE\_シーケンス**-デバイスからデータを読み取る I/O 転送シーケンスを実行します。 このシーケンスの最初の転送は、関数アドレス レジスタにバイト書き込みです。 シーケンス内の 2 つ目の転送では、いくつかの選択した関数のアドレスからのバイトの読み取りです。 バスには、これら 2 つの転送がアトミックに実行されます。
2.  **IRP\_MJ\_書き込み**-デバイスにデータを記述します。 この要求の書き込みバッファーの最初のバイトは、関数アドレス レジスタに記述する値です。 バッファー内の残りのバイトは、選択した関数アドレスに書き込むデータです。

要求の他のパターンは、読み取り/変更/書き込み操作を実行する代わりに使用可能性があります。 たとえば、 **IRP\_MJ\_書き込み**要求手順 2. で置き換えることができます、 **IOCTL\_SPB\_EXECUTE\_シーケンス**要求どちらも書き込み、2 つのデータ転送を指定します。 シーケンスの最初の転送は、関数アドレス レジスタにバイトを読み込みます。 2 番目の転送は、選択した関数のアドレスにデータのバイトを書き込みます。 この要求とは異なり、 **IRP\_MJ\_書き込み**手順 2. では、関数アドレス バイトと同じ書き込みバッファーでデータ バイトを結合するクライアントは必要ありません。

このデバイスで関数アドレス 0 で、読み取り/変更/書き込みを実行する、 **IOCTL\_SPB\_EXECUTE\_シーケンス**単純な読み取りは、上記の手順 1 で要求を置き換えることができます ([ **IRP\_MJ\_読み取り**](https://msdn.microsoft.com/library/windows/hardware/ff550794)) 要求します。

 

 




