---
title: 汎用入出力 (GPIO)
description: チップ (SoC) が搭載されたシステムでは、汎用 i/o (GPIO) ピンが広く使用されています。
ms.assetid: 9EB4EFC3-B94E-42C9-9FC7-12DF4AD01622
ms.date: 07/09/2018
ms.localizationpriority: medium
ms.openlocfilehash: 38b0f118791afc1c5b7070ad4cc35bba99dd5d19
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72834499"
---
# <a name="general-purpose-io-gpio"></a>汎用入出力 (GPIO)


チップ (SoC) が搭載されたシステムでは、汎用 i/o (GPIO) ピンが広く使用されています。 SoC ベースのプラットフォームの場合、Windows は GPIO ハードウェアの一般的な抽象化を定義します。この抽象化には、Advanced Configuration and Power Interface (ACPI) 名前空間のサポートが必要です。

GPIO 抽象化は、この記事に記載されている[ACPI 5.0 仕様](https://uefi.org/specifications)の定義でサポートされています。

GPIO コントローラーがすべての Windows プラットフォームの要件を満たしていることを確認するには、「 [Gpio コントローラーの要件のチェックリスト](gpio-controller-requirements-checklist.md)」を参照してください。

## <a name="gpio-controller-devices"></a>GPIO コントローラーデバイス


Windows は、GPIO コントローラーをサポートしています。 GPIO コントローラーは、割り込み、入力信号、出力シグナル通知など、周辺機器用のさまざまな機能を提供します。 GPIO 機能は、名前空間の GPIO コントローラーデバイスとしてモデル化されています。 [Gpio framework 拡張機能](https://docs.microsoft.com/windows-hardware/drivers/gpio/gpio-driver-support-overview)(gpioclx) は、複数の pin のバンクにパーティション分割されているとして、gpio コントローラーデバイスをモデル化します。 各ピンバンクには、64以下の構成可能な pin があります。 GPIO コントローラーの銀行は、コントローラー相対の GPIO ピンスペース内でのピンの位置に対して相対的に並べられています。 たとえば、バンク0にはコントローラーのピン0-31 が含まれ、バンク1にはピン32-63 が含まれます。 すべての銀行の pin の数は同じですが、最後のバンクを除きます。 次の「 **GPIO namespace オブジェクト**」セクションで説明されているように、ファームウェアはシステム割り込みリソースの銀行へのマッピングを報告する必要があるため、銀行は ACPI ファームウェアにとって重要です。

銀行の各ピンには、pin の構成方法を説明する一連のパラメーター (出力、レベルを区別する割り込み、逆バウンス入力など) があります。

**GPIO コントローラーと ActiveBoth 割り込み**

一部の GPIO コントローラーの機能は、信号の両方の端 (上昇、または ActiveHigh、または Activehigh のエッジ) で割り込みを生成する機能です。 これは、ボタンインターフェイスを含むさまざまなアプリケーションで役立ちます。ボタンのクリックイベント (1 つの端) とボタン解放イベント (反対側の端) の両方が意味を持ちます。 この機能は "ActiveBoth" と呼ばれます。

論理的には、両方のシグナルにはアサートされた状態とアサートされていない状態があります。これらの状態は、瞬間的なアサーション (プッシュボタンなど) でも、長いアサーション (ヘッドホンジャックの挿入など) でもあります。 アクティブなエッジ検出は、両方の割り込みが GPIO controller ハードウェア (ハードウェア ActiveBoth) に実装されているか、GPIO ドライバーソフトウェア (エミュレートされた ActiveBoth) でエミュレートされている可能性があります。 Windows では、ActiveBoth を実装する GPIO controller が、エミュレートされた ActiveBoth を使用する必要があります。 これは、すべてのシナリオで、二重のエッジの割り込みを確実に処理するために必要です。 ActiveBoth エミュレーションのサポートでは、次のハードウェア要件が適用されます。

1.  アクティブな両方の割り込みをサポートする GPIO コントローラーは、レベルモードの割り込みをサポートする必要があります。また、実行時に割り込みの極性を動的に再プログラミングすることをサポートする必要があります。
2.  I/o エラーのリスクを最小限に抑えるために、Windows では、SPB 接続の GPIO コントローラーではなく、メモリマップト GPIO コントローラーを使用することを推奨しています。 実際、Windows ボタン配列デバイス (PNP0C40) については、このデバイスの両方の GPIO 割り込みが、SPB に接続されているものではなく、メモリにマップされた GPIO コントローラーに接続する必要があります。 どのボタン割り込みをアクティブにする必要があるかを判断するには、「[その他の ACPI 名前空間オブジェクト](other-acpi-namespace-objects.md)」トピックの「**ボタンデバイス」** セクションを参照してください。
3.  Windows GPIO デバイススタックは、アクティブな両方の割り込みシグナルに対して決定的な初期状態を確立するために、ドライバーによる割り込みの接続後に生成される最初の割り込みが常にシグナルのアサート状態になることを保証します。 スタックは、既定では、すべてのアクティブな両方の割り込み行のアサート状態がロジックレベル low (Activeboth edge) であることを前提としています。 そうでない場合は、コントローラーの名前空間に GPIO コントローラーデバイス固有のメソッド (\_DSM) を含めることで、既定の設定を上書きできます。 この方法の詳細については、「 [GPIO Controller デバイス固有の方法 (\_DSM)](gpio-controller-device-specific-method---dsm-.md)」を参照してください。

> [!NOTE]
> 上記の3番目の要件は、ActiveBoth の信号がその時点でアサートされた状態にある場合に、ActiveBoth を使用するデバイスのドライバーが、割り込みを初期化 (接続) した直後に割り込みを受け取る可能性があることを示しています。 これは可能であり、一部のデバイス (たとえば、ヘッドホン) でも可能性があり、ドライバーでサポートされている必要があります。

 

エミュレートされた ActiveBoth をサポートするには、[*クライアント\_ReconfigureInterrupt*](https://docs.microsoft.com/windows-hardware/drivers/ddi/gpioclx/nc-gpioclx-gpio_client_reconfigure_interrupt) callback 関数を実装し、基本の**EmulateActiveBoth**フラグを設定することにより、GPIO コントローラードライバーが両方のエミュレーションを有効にする必要があります。ドライバーの[*クライアント\_Queryコントローラー basicinformation*](https://docs.microsoft.com/windows-hardware/drivers/ddi/gpioclx/nc-gpioclx-gpio_client_query_controller_basic_information) callback 関数が**Gpioclx**に提供する情報構造。 詳細については、「[汎用 i/o (GPIO) ドライバー](https://docs.microsoft.com/windows-hardware/drivers/gpio)」を参照してください。

## <a name="gpio-namespace-objects"></a>GPIO 名前空間オブジェクト


GPIO コントローラーとそれらに接続する周辺機器は、ACPI によって列挙されます。 これらの間の接続については、「GPIO Connection リソース記述子」を参照してください。 詳細については、ACPI 5.0 仕様のセクション6.4.3.8 「接続記述子」を参照してください。

**デバイス id と構成オブジェクト**

GPIO コントローラーデバイスの ACPI 名前空間には、次のものが含まれます。

-   ベンダによって割り当てられた ACPI 準拠のハードウェア ID (\_HID) オブジェクト。
-   消費されたリソースのセット (\_CRS)。
-   名前空間に複数の GPIO コントローラーのインスタンスが存在する場合は、一意の ID (\_UID) オブジェクト。これは、同じデバイス id オブジェクトを持つ2つ以上の名前空間ノードです。

GPIO コントローラーの \_CRS には、GPIO コントローラー内のすべての銀行が使用するすべてのリソース (レジスタのアドレス空間、システム割り込みなど) が含まれています。 割り込みリソースから銀行へのマッピングは、\_CRS に割り込みリソースが表示される順序で表されます。つまり、一覧表示されている最初の割り込みが銀行0に割り当てられ、次の割り込みが銀行1に割り当てられます。 銀行は割り込みリソースを共有できます。この場合、割り込みは銀行ごとに1回、銀行の注文で、共有として構成されます。

**GPIO 接続リソース記述子**

接続されている周辺機器と GPIO ピンの関係は、オペレーティングシステムによって、GPIO 接続リソース記述子によって示されます。 これらのリソース記述子は、GPIO 割り込み接続と GPIO i/o 接続という2種類の GPIO 接続を定義できます。 周辺機器には、すべての GPIO i/o と、接続されている割り込みピンの \_CRS に GPIO 接続記述子が含まれています。 接続されている割り込みがウェイク対応 (低電力アイドル状態からシステムをウェイクアップできる) の場合は、ExclusiveAndWake または SharedAndWake として構成する必要があります。詳細については、「[デバイスの電源管理](device-power-management.md)」を参照してください。

これらの記述子は、ACPI 5.0 仕様のセクション 6.4.3.8.1 "GPIO Connection Descriptor" で定義されています。 これらの記述子の ASL リソーステンプレートマクロは、ACPI 5.0 仕様のセクション19.5.53 「GpioInt (GPIO Interrupt Connection Resource Descriptor Macro)」で説明されています。

**GPIO シグナル状態の ACPI イベント**

ACPI は、プラットフォームのハードウェアイベントを通知し、ACPI ドライバーに伝達できるようにするプラットフォームイベントモデルを定義します。 Windows は、デバイスドライバーに対してプラットフォームイベントを通信するための通知サービスを提供します。 多くの受信トレイドライバーは、このサービスに依存して、コントロールメソッドの電源ボタン、カバーデバイス、制御方法のバッテリ、温度帯など、ACPI で定義されたデバイスのサポートを提供します。 通知の詳細については、ACPI 仕様のセクション5.6.5 「GPIO ACPI イベント」を参照してください。

SoC プラットフォームの場合、GPIO 割り込みはプラットフォームイベントを通知するために使用されます。 ASL Notify オペレーターを使用してイベントをドライバーに通知するすべての名前空間デバイス ("ACPI イベントソース" デバイス) には、次のものが必要です。

-   ACPI イベントシグナルが接続されている GPIO コントローラーの名前空間ノードには、その pin の GpioInt リソースが ACPI イベント情報 (\_AEI) オブジェクトに含まれている必要があります (以下の「2.4.2.3.1、ACPI イベント情報 (\_AEI) オブジェクト」を参照してください)。 GpioInt リソースは、非共有 (排他) として構成する必要があります。
-   また、コントローラーのノードには、\_AEI オブジェクトに記載されている各 pin の Edge (\_Exx)、Level (\_Lxx)、または Event (\_.EVT) コントロールメソッドも含まれている必要があります。

ACPI ドライバーは、一覧表示された GPIO 割り込みを処理し、その中のエッジ、レベル、またはイベント制御メソッドを評価します。 コントロールメソッドは、必要に応じてハードウェアイベントを quiesces し、イベントソースデバイスの名前空間ノードで必要な Notify 操作を実行します。 その後、Windows によってデバイスのドライバーに通知が送信されます。 イベント制御メソッドがハードウェアに対してクエリを実行して発生したイベントを特定できる場合、同じ GpioInt リソースに対して複数のイベントを通知できます。 メソッドは、正しい通知コードを使用して正しいデバイスに通知する必要があります。

*ACPI イベント情報 (\_AEI) オブジェクト*

前述のように、GPIO コントローラーの名前空間には、ACPI イベントをサポートするために \_AEI オブジェクトが含まれている必要があります。 \_AEI オブジェクト (ACPI 5.0 仕様のセクション5.6.5.2 を参照) は、この GPIO コントローラー経由で ACPI イベントを通知する GpioInt 記述子のみを含むリソーステンプレートバッファーを返します。 各記述子は、1つの ACPI イベントソースデバイスに対応し、そのデバイス専用です (デバイス間で共有されません)。

**GeneralPurposeIO 操作領域 (OpRegions)**

多くの場合、GPIO コントローラーはプラットフォームファームウェアによって使用され、電源とクロックの制御やデバイスのモードの設定など、任意の数のプラットフォームハードウェア機能をサポートします。 ASL 制御メソッドからの GPIO i/o の使用をサポートするために、ACPI 5.0 では、新しい OpRegion 型 "GeneralPurposeIO" が定義されています。

GeneralPurposeIO OpRegions (ACPI 5.0 仕様のセクション5.5.2.4.4 を参照) は、ドライバーが i/o を処理する GPIO コントローラーデバイスの名前空間のスコープ内で宣言されます。 GeneralPurposeIO フィールド宣言 (ACPI 5.0 仕様のセクション5.5.2.4.4.1 を参照) は、GeneralPurposeIO OpRegion 内でアクセスされる GPIO ピンに名前を割り当てます。 GpioIO 接続リソース (ACPI 5.0 仕様のセクション19.5.53 を参照) は、フィールドの宣言内で、特定のフィールド参照の pin 番号と構成を指定するために使用されます。 接続記述子に続く名前付きフィールドビットの合計数は、記述子に示されている pin の数と同じである必要があります。

OpRegion 内のフィールドは、名前空間内の任意の場所で宣言し、名前空間の任意のメソッドからアクセスできます。 GeneralPurposeIO OpRegion へのアクセス方向は、最初のアクセス (読み取りまたは書き込み) によって決定され、変更することはできません。

> [!NOTE]
> OpRegion アクセスは GPIO コントローラーデバイスドライバー ("OpRegion ハンドラー") によって提供されるため、メソッドは、ドライバーが使用可能になるまで、OpRegion にアクセスしないように注意する必要があります。 ASL コードでは、GPIO コントローラーデバイスの下に Region (\_REG) メソッドを含めることで、OpRegion ハンドラーの状態を追跡できます (ACPI 5.0 仕様の6.5.4 セクションを参照してください)。 また、必要に応じて、GPIO OpRegion フィールドにアクセスするメソッドを持つ任意のデバイスで、OpRegion Dependencies (\_DEP) オブジェクト (ACPI 5.0 仕様のセクション6.5.8 を参照) を使用できます。 \_DEP を使用する場合の詳細については、[デバイス管理の名前空間オブジェクト](device-management-namespace-objects.md)に関するトピックの「**デバイスの依存関係**」セクションを参照してください。 ドライバーには、GeneralPurposeIO OpRegions にも割り当てられている GPIO i/o リソースが割り当てられていないことが重要です。 Opregions は、ASL 制御メソッドを排他的に使用するためのものです。

 
