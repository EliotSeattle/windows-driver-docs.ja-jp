---
title: ネットワーク ドライバーの同期と通知
description: ネットワーク ドライバーの同期と通知
ms.assetid: 9fd9306f-5431-485f-9d6b-f7d6f25ea1ce
keywords:
- リソースへのアクセスの同期 WDK ネットワーク
- WDK ネットワークの同期
- 通知 WDK ネットワーク
- スピンロックの WDK ネットワーク
- ネットワークドライバー WDK, イベントについてドライバーに通知する
- イベントに関する情報をドライバーに通知する WDK ネットワーク
- 共有リソース WDL ネットワーク
- タイマー WDK ネットワーク
- イベント通知の WDK ネットワーク
- イベント WDK ネットワーク
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 62dab1c7db47beafcf9dca59813820b28f7707a7
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72841792"
---
# <a name="synchronization-and-notification-in-network-drivers"></a>ネットワーク ドライバーの同期と通知





ユニプロセッサコンピューターでも対称型マルチプロセッサ (SMP) コンピューターでも、2つの実行スレッドが同時にアクセスできるリソースを共有する場合は、同期する必要があります。 たとえば、ユニプロセッサコンピューターで、あるドライバー関数が共有リソースにアクセスしていて、ISR などの高い IRQL で実行されている別の関数によって中断されている場合、共有リソースを保護して、次のような競合状態が発生しないようにする必要があります。不確定の状態。 SMP コンピューターでは、2つのスレッドが異なるプロセッサで同時に実行され、同じデータを変更しようとしている可能性があります。 このようなアクセスは同期する必要があります。

NDIS にはスピンロックが用意されており、同じ IRQL で実行されるスレッド間で共有リソースへのアクセスを同期するために使用できます。 リソースを共有する2つのスレッドが異なる IRQLs で実行されている場合、NDIS は、共有リソースへのアクセスをシリアル化できるように、下位の IRQL コードの IRQL を一時的に上げるメカニズムを提供します。

スレッドがスレッド外のイベントの発生に依存している場合、スレッドは通知に依存します。 たとえば、デバイスを確認できるように、ある期間が経過したときにドライバーに通知する必要がある場合があります。 または、ネットワークインターフェイスカード (NIC) ドライバーがポーリングなどの定期的な操作を実行することが必要になる場合があります。 タイマーは、このようなメカニズムを提供します。

イベントは、実行の2つのスレッドが操作の同期に使用できるメカニズムを提供します。 たとえば、ミニポートドライバーは、デバイスへの書き込みによって、NIC の割り込みをテストできます。 ドライバーは、割り込みによる操作が成功したことをドライバーに通知する必要があります。 イベントを使用して、割り込みの完了を待機しているスレッドと、その割り込みを処理するスレッドとの間の操作を同期できます。

このトピックの次のサブセクションでは、これらの NDIS 機構について説明します。

-   [スピンロック](#spin-locks)
-   [スピンロックの問題の回避](#avoiding-spin-lock-problems)
-   [タイ](#timers)
-   [記録](#events)

### <a name="spin-locks"></a>スピン ロック

*スピンロック*は、ユニプロセッサまたはマルチプロセッサコンピューターで、IRQL &gt; パッシブ\_レベルで実行されているカーネルモードスレッドによって共有されるリソースを保護するための同期機構を提供します。 スピンロックは、SMP コンピューターで同時に実行されているさまざまな実行スレッド間の同期を処理します。 スレッドは、保護されたリソースにアクセスする前にスピンロックを取得します。 スピンロックは、すべてのスレッドを保持しますが、スピンロックを保持するスレッドはリソースを使用しません。 SMP コンピューターでは、スピンロックを待機しているスレッドが、ロックを保持しているスレッドによって解放されるまで、スピンロックを取得しようとします。

スピンロックのもう1つの特性は、関連する IRQL です。 スピンロックを取得しようとすると、そのスピンロックに関連付けられている IRQL に対して、要求元のスレッドの IRQL が一時的に発生します。 これにより、同じプロセッサ上のすべての低い IRQL スレッドが、実行中のスレッドを遮断するのを防ぐことができます。 同じプロセッサ上で、高い IRQL で実行されているスレッドは、実行中のスレッドを横取りできますが、これらのスレッドは、低い IRQL を持つため、スピンロックを取得できません。 そのため、スレッドがスピンロックを取得した後、解放されるまで、他のスレッドがスピンロックを取得することはできません。 適切に記述されたネットワークドライバーを利用すると、スピンロックが保持される時間を最小限に抑えることができます。

スピンロックの一般的な用途は、キューを保護することです。 たとえば、ミニポートドライバーの send 関数である[*Miniportsendnetbufferlists*](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nc-ndis-miniport_send_net_buffer_lists)は、プロトコルドライバーによって渡されたパケットをキューに置いている可能性があります。 他のドライバー関数でもこのキューが使用されるため、 *Miniportsendnetbufferlists*は、一度に1つのスレッドのみがリンクまたはコンテンツを操作できるように、スピンロックを使用してキューを保護する必要があります。 *Miniportsendnetbufferlists*は、スピンロックを取得し、そのパケットをキューに追加してから、スピンロックを解放します。 スピンロックを使用すると、パケットがキューに安全に追加されている間に、ロックを保持しているスレッドがキューリンクを変更する唯一のスレッドになります。 ミニポートドライバーがパケットをキューから取得すると、そのようなアクセスは同じスピンロックによって保護されます。 キューの先頭またはキューを構成するいずれかのリンクフィールドを変更する命令を実行する場合、ドライバーは、スピンロックを使用してキューを保護する必要があります。

ドライバーは、キューを過剰に保護しないように注意する必要があります。 たとえば、ドライバーは、パケットをキューに格納する前に、パケットのネットワークドライバーで予約されているフィールドに、何らかの操作 (長さを含むフィールドの入力など) を実行できます。 ドライバーは、スピンロックによって保護されているコード領域の外部でこの操作を行うことができますが、パケットをキューにする前に実行する必要があります。 パケットがキューに入れられ、実行中のスレッドがスピンロックを解放すると、ドライバーは、他のスレッドがパケットを直ちにデキューできると想定する必要があります。

### <a name="avoiding-spin-lock-problems"></a>スピンロックの問題の回避

デッドロックの可能性を回避するために、ndis ドライバーは、ndis ***Xxx*** スピンロック関数以外の ndis 関数を呼び出す前に、すべての ndis スピンロックを解放する必要があります。 NDIS ドライバーがこの要件に準拠していない場合は、次のようなデッドロックが発生する可能性があります。

1. NDIS スピンロック A を保持するスレッド1は、 [**NdisAcquireSpinLock**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisacquirespinlock)関数を呼び出して ndis スピンロック B を取得しようとする**ndis * Xxx*** 関数を呼び出します。

2. NDIS スピンロック B を保持するスレッド2は、 **NdisAcquireSpinLock**関数を呼び出して、ndis スピンロック A を取得しようとする**ndis * Xxx*** 関数を呼び出します。

3. スレッド1とスレッド2は、それぞれがスピンロックを解放するのを待機しているため、デッドロック状態になります。

Microsoft Windows オペレーティングシステムでは、ネットワークドライバーに複数のスピンロックが同時に保持されるのを制限していません。 ただし、スピンロック B を保持した状態で、ドライバーの1つのセクションでスピンロック b を取得しようとし、別のセクションでスピンロック A を保持しながらスピンロック B を取得しようとすると、デッドロックの結果になります。 複数のスピンロックを取得した場合、ドライバーは取得の順序を強制することでデッドロックを回避する必要があります。 つまり、スピンロック B の前に、ドライバーがスピンロックを取得するように強制した場合、上記で説明した状況は発生しません。

スピンロックを取得すると、\_レベルをディスパッチする IRQL が発生し、古い IRQL がスピンロックに格納されます。 スピンロックを解放すると、IRQL がスピンロックに格納されている値に設定されます。 NDIS はパッシブ\_レベルでドライバーを入力することがあるため、次のコードシーケンスを使用すると問題が発生する可能性があります。

```syntax
NdisAcquireSpinLock(A);
NdisAcquireSpinLock(B);
NdisReleaseSpinLock(A);
NdisReleaseSpinLock(B);
```

ドライバーは、次の理由により、このシーケンスのスピンロックにアクセスしないようにする必要があります。

-   スピンロック A を解放して、スピンロック B を解放するまでの間、コードは\_レベルをディスパッチするのではなくパッシブ\_レベルで実行され、不適切な中断が適用されます。

-   スピンロック B を解放した後、コードはディスパッチ\_レベルで実行されています。これにより、呼び出し元は\_IRQL によって後でエラーが発生し\_\_または\_に等しい停止エラーが発生する可能性があります。

スピンロックの使用はパフォーマンスに影響を及ぼします。通常、ドライバーは多くのスピンロックを使用しないようにします。 場合によっては、通常は別の関数 (送信関数や受信関数など) では、2つのスピンロックを使用できるように若干の重なりが発生します。 複数のスピンロックを使用すると、2つの関数を別々のプロセッサで個別に操作できるようになります。

### <a name="timers"></a>タイ

タイマーは、ポーリングまたはタイムアウト操作に使用されます。 ドライバーはタイマーを作成し、関数をタイマーに関連付けます。 タイマーに指定された期間が経過すると、関連付けられている関数が呼び出されます。 タイマーは、ワンショットまたは定期的に行うことができます。 周期的なタイマーが設定されると、明示的にクリアされるまで、すべての期間の有効期限時に継続して起動されます。 ワンショットタイマーは、起動するたびにリセットする必要があります。

タイマーは、 [**NdisAllocateTimerObject**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisallocatetimerobject)を呼び出し、 [**NdisSetTimerObject**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndissettimerobject)を呼び出して設定することによって作成および初期化されます。 非周期タイマーを使用する場合は、 **NdisSetTimerObject**を呼び出してリセットする必要があります。 タイマーは、 [**NdisCancelTimerObject**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndiscanceltimerobject)を呼び出すことによってクリアされます。

### <a name="events"></a>イベント

イベントは、実行の2つのスレッド間の操作を同期するために使用されます。 イベントは、ドライバーによって割り当てられ、 [**NdisInitializeEvent**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisinitializeevent)を呼び出すことによって初期化されます。 IRQL = パッシブ\_レベルで実行されているスレッドは、 [**NdisWaitEvent**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndiswaitevent)を呼び出して待機状態になります。 ドライバースレッドは、イベントで待機するときに、待機する最大時間と待機するイベントを指定します。 [**NdisSetEvent**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndissetevent)が呼び出され、イベントがシグナル状態になるか、指定された最大待機時間の有効期限が切れると、スレッドの待機が完了します。

通常、イベントは、 **NdisSetEvent**を呼び出す協調スレッドによって設定されます。 イベントは、作成時に非シグナルされ、待機中のスレッドをシグナル通知するために設定する必要があります。 イベントは、 [**NdisResetEvent**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ndis/nf-ndis-ndisresetevent)が呼び出されるまでシグナル状態のままになります。

## <a name="related-topics"></a>関連トピック


[ネットワークドライバーでのマルチプロセッサのサポート](multiprocessor-support-in-network-drivers.md)

 

 






