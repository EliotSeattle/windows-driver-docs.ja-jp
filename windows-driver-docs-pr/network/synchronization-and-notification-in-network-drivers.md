---
title: ネットワーク ドライバーの同期と通知
description: ネットワーク ドライバーの同期と通知
ms.assetid: 9fd9306f-5431-485f-9d6b-f7d6f25ea1ce
keywords:
- WDK ネットワークのリソースへのアクセスを同期します。
- WDK ネットワークの同期
- 通知の WDK ネットワーク
- スピン ロック WDK ネットワーク
- ネットワーク ドライバー WDK、ドライバーのイベントに関する通知
- イベントの WDK ネットワークのドライバーを通知します。
- 共有リソース WDL ネットワーク
- タイマーの WDK ネットワーク
- イベント通知の WDK ネットワーク
- イベントの WDK ネットワーク
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 419fb53f0e53eecb6441c148ad975dcb70622c32
ms.sourcegitcommit: 0cc5051945559a242d941a6f2799d161d8eba2a7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "63362550"
---
# <a name="synchronization-and-notification-in-network-drivers"></a>ネットワーク ドライバーの同期と通知





実行の 2 つのスレッドが単一プロセッサのコンピューターで、または対称マルチプロセッサ (SMP) コンピューターでは、同時にアクセスできるリソースを共有するたびに、同期する必要があります。 たとえば、ユニプロセッサ コンピューター ドライバー機能の 1 つが共有リソースへのアクセスは、ISR などのより高い IRQL でを実行するもう 1 つの関数が中断された場合、共有リソース保護する必要をそのリソースで競合状態を防ぐために中間状態です。 SMP コンピューターは、2 つのスレッドを別のプロセッサで同時に実行されていると、同じデータを変更しようとする可能性があります。 このようなアクセスを同期する必要があります。

NDIS は、同じ IRQL でを実行しているスレッド間で共有リソースへのアクセスを同期するために使用できるスピン ロックを提供します。 リソースを共有する 2 つのスレッドは、さまざまな Irql で実行、NDIS は共有リソースへのアクセスをシリアル化できるように、IRQL の下のコードの IRQL を一時的に発生させるためのメカニズムを提供します。

スレッドは、スレッドの外部イベントの発生に依存しているときに、スレッドは通知に依存します。 たとえば、ドライバーは、そのデバイスをチェックできるように、一定の期間が経過したときに通知する必要があります。 または、ネットワーク インターフェイス カード (NIC) ドライバーは、ポーリングなどの定期的な操作を実行する必要があります。 タイマーは、このようなメカニズムを提供します。

イベントは、実行の 2 つのスレッドを使用して操作を同期するメカニズムを提供します。 たとえば、ミニポート ドライバーでは、デバイスへの書き込みによって NIC で割り込みをテストできます。 ドライバーは、操作が成功したことをドライバーに通知する割り込みを待つ必要があります。 イベントは、割り込みを完了するのにを待っているスレッドと、割り込みを処理するスレッド間の演算を同期を使用することができます。

このトピックでは、次のサブセクションでは、これらの NDIS メカニズムについて説明します。

-   [スピン ロック](#spin-locks)
-   [スピン ロックの問題を回避します。](#avoiding-spin-lock-problems)
-   [タイマー](#timers)
-   [イベント](#events)

### <a name="spin-locks"></a>スピン ロック

A*スピン ロック*IRQL で実行されているカーネル モードのスレッドによって共有されるリソースを保護する同期メカニズムを提供します&gt;パッシブ\_ユニプロセッサまたはマルチプロセッサ コンピューターのいずれかのレベル。 スピン ロックでは、SMP のコンピューターで同時に実行する実行のさまざまなスレッド間で同期を処理します。 スレッドでは、保護されたリソースにアクセスする前に、スピン ロックを取得します。 スピン ロックでは、スピン ロックしてから、リソースを使用して、1 つのいずれかのスレッドを保持します。 SMP コンピューターで、スレッドが解放されるまでに、スピン ロックを取得しようとして、スピン ロック ループで待機しているスレッドをロックを保持します。

スピン ロックのもう 1 つの特性は、関連付けられている IRQL です。 スピン ロックの取得を実行しようとしたは、スピン ロックに関連付けられている IRQL を要求しているスレッドの IRQL を一時的に生成します。 これは、同じプロセッサ上のすべての下位 IRQL スレッドが実行中のスレッドを優先することを防ぎます。 高い IRQL で実行されている、同じプロセッサ上のスレッドが実行中のスレッドを切断できますが、これらのスレッドが低いかどうかがあるため、スピン ロックを取得できません。 そのため、スレッドは、スピン ロックが取得された後に他のスレッドを取得できますありませんスピン ロックがリリースされるまで。 適切に記述されたネットワーク ドライバーは、スピン ロックが保持される時間を最小限に抑えます。

スピンロックの一般的な用途は、キューを保護します。 たとえば、ミニポート ドライバーに送信関数、 [ *MiniportSendNetBufferLists*](https://msdn.microsoft.com/library/windows/hardware/ff559440)、プロトコル ドライバーによって渡されたパケットをキューに可能性があります。 その他のドライバー機能も、このキューを使用するため*MiniportSendNetBufferLists*一度に 1 つのスレッドは、リンクやその内容を操作できるように、スピン ロックでキューを保護する必要があります。 *MiniportSendNetBufferLists*スピン ロックを取得、パケットをキューに追加して、スピン ロックを解放します。 スピン ロックを使用して、ロックを保持しているスレッドが、パケットがキューに安全に追加中に、キューへのリンクを変更する唯一のスレッドにより。 ミニポート ドライバーでは、キューからのパケットを受け取り、このようなアクセスが同じスピン ロックで保護されます。 キューまたはキューを作成するリンク フィールドのいずれかのヘッドを変更する手順を実行するときに、ドライバーはスピン ロックでキューを保護する必要があります。

ドライバーは、投じなくてキューが注意する必要があります。 たとえば、ドライバーで実行できますいくつかの操作 (たとえば、長さを含むフィールドを入力) パケットのネットワーク ドライバーで予約されているフィールド、パケットをキューに配置する前に。 ドライバーは、スピン ロックで保護されたコード領域の外側のこれを行うことができますが、前に、パケットをキューに行う必要があります。 パケットがキューに、スピン ロックを解放する実行中のスレッドを後、ドライバーは、他のスレッドのデキューでパケットがすぐに処理できますと想定する必要があります。

### <a name="avoiding-spin-lock-problems"></a>スピン ロックの問題を回避します。

デッドロックが発生を避けるためには、NDIS ドライバーは、以外、NDIS 関数を呼び出す前にすべての NDIS スピン ロックを解放する必要があります、 **Ndis*Xxx*スピンロック**関数。 NDIS ドライバーは、この要件に準拠していない場合に、次のようにデッドロックが発生する可能性があります。

1. NDIS スピン ロック A を保持するには、スレッド 1 が、 **Ndis * Xxx*** NDIS の取得を試みますが呼び出すことによってロック B をスピン関数、 [ **NdisAcquireSpinLock** ](https://msdn.microsoft.com/library/windows/hardware/ff560699)関数。

2. スレッド 2 では、NDIS スピン ロックを呼び出し、B を保持する、 **Ndis * Xxx*** NDIS スピン ロック A を呼び出すことによって取得を試行する関数、 **NdisAcquireSpinLock**関数。

3. そのスピン ロックを解放するその他の各待機していますが、スレッド 1 とスレッド 2 とデッドロックが発生します。

Microsoft Windows オペレーティング システムでは、同時に 1 つ以上のスピン ロックを保持しているからネットワーク ドライバーは制限されません。 ただし、ドライバーの 1 つのセクションでは、スピン ロック A を押しながらスピン ロック B を取得しようとしてスピン ロック B、および別のセクションを保持しているときに、スピン ロック A を取得しようとして、デッドロックが発生します。 1 つ以上のスピン ロックを獲得、ドライバーは、取得の順序を強制することによりデッドロックを避ける必要があります。 つまり、ドライバーは、スピン ロック B の前にスピン ロック A 取得を適用、上記で説明したような状況は発生しません。

ディスパッチする IRQL を発生させるスピン ロックの獲得\_とストア、スピン ロックで古い IRQL のレベル。 スピン ロックを解放する、IRQL をスピン ロックで格納されている値に設定します。 NDIS パッシブでドライバーを入力場合がありますので\_レベル、問題が次のコード シーケンスで発生することができます。

```syntax
NdisAcquireSpinLock(A);
NdisAcquireSpinLock(B);
NdisReleaseSpinLock(A);
NdisReleaseSpinLock(B);
```

ドライバーでは、次の理由でこのシーケンスで、スピン ロックはアクセスしないでください。

-   間スピン ロック A を解放して解放を行うスピン ロック B、パッシブでコードが実行されている\_ディスパッチではなくレベル\_レベルと、不適切なが中断される可能性があります。

-   解放した後スピン ロック B、ディスパッチでコードが実行されている\_IRQL を後で呼び出し元が障害を原因となるレベル\_いない\_少ない\_または\_等しい stop エラーが発生します。

スピン ロックを使用して、パフォーマンスに影響して、一般に、ドライバーが多数のスピン ロックを使用しないでください。 通常、個別の関数場合によっては、(たとえば、送信および受信機能) マイナー重複させるが 2 つのスピン ロックを使用できます。 1 つ以上のスピン ロックの使用には、別々 のプロセッサで独立して動作する 2 つの関数を許可するには価値のあるトレードオフ可能性があります。

### <a name="timers"></a>タイマー

タイマーは、ポーリングまたは操作がタイムアウトに使用されます。 ドライバーは、タイマーを作成し、タイマー関数に関連付けます。 タイマーで指定された期間の期限が切れると、関連付けられている関数が呼び出されます。 タイマーは、1 回限りまたは定期的なを指定できます。 定期的なタイマーを設定するを明示的にクリアされるまで、各期間の期限切れの起動が続行されます。 ワンショット タイマーは、発生させるたびにリセットする必要があります。

タイマーが作成され、呼び出すことによって初期化[ **NdisAllocateTimerObject** ](https://msdn.microsoft.com/library/windows/hardware/ff561618)呼び出すことによって設定および[ **NdisSetTimerObject**](https://msdn.microsoft.com/library/windows/hardware/ff564563)します。 非連続のタイマーを使用すると、呼び出すことでリセットする必要があります**NdisSetTimerObject**します。 タイマーが呼び出すことによってオフになって[ **NdisCancelTimerObject**](https://msdn.microsoft.com/library/windows/hardware/ff561624)します。

### <a name="events"></a>イベント

イベントは、2 つのスレッドの実行の間の操作を同期に使用されます。 イベントは、ドライバーによって割り当てられ、呼び出すことによって初期化[ **NdisInitializeEvent**](https://msdn.microsoft.com/library/windows/hardware/ff562732)します。 IRQL で実行しているスレッド = パッシブ\_レベル呼び出し[ **NdisWaitEvent** ](https://msdn.microsoft.com/library/windows/hardware/ff564651)自体、待機状態にします。 ドライバー スレッドは、イベントを待機している場合は、待機する最大時間だけ待機するイベントを指定します。 スレッドの待機がときに満たされて[ **NdisSetEvent** ](https://msdn.microsoft.com/library/windows/hardware/ff564539)がシグナルを送信するイベントを発生させた呼び出されるか、指定された最大待機時間間隔期限が切れたとき、どちらが最初に発生します。

呼び出す協調スレッドによって、イベントを設定する通常、 **NdisSetEvent**します。 作成されと待機中のスレッドを通知するために設定する必要がありますが、イベントはシグナルれません。 イベントがまでシグナル状態になります[ **NdisResetEvent** ](https://msdn.microsoft.com/library/windows/hardware/ff564526)が呼び出されます。

## <a name="related-topics"></a>関連トピック


[ネットワークのドライバーでマルチプロセッサ サポート](multiprocessor-support-in-network-drivers.md)

 

 






