---
title: SAN のソケット ハンドルの複製
description: SAN のソケット ハンドルの複製
ms.assetid: d8e8cb6d-fcdb-4121-9a44-a2bc884ab620
keywords:
- Windows ソケットの直接の WDK ソケットを処理します。
- SAN ソケット WDK、ソケット ハンドルを複製します。
- WDK Windows Sockets 直接保留
- WDK の San を処理するソケットの複製
- 基になるソケット WDK San を共有
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 6bafb3c2242cbb22fe1508399400f1c7a6fe50f9
ms.sourcegitcommit: 0cc5051945559a242d941a6f2799d161d8eba2a7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "63372643"
---
# <a name="duplicating-socket-handles-for-a-san"></a>SAN のソケット ハンドルの複製





別のプロセスで実行される複数のアプリケーションは、Windows Sockets スイッチを使用して、共有の基になるソケットに対する操作を実行できます。 ただし、一度に 1 つだけのアプリケーションでは、その共有の基になるソケットでの操作を実行できます。

共有の基になるソケットを使用するには、アプリケーションは、次の方法のいずれかでその基になるソケットに重複するハンドルを取得する必要があります。

-   Windows ソケットを直接呼び出して**WSADuplicateSocket**関数

    呼び出しの制御プロセスのコンテキスト (プロセスのソケットが作成された)。

-   Win32 DuplicateHandle 関数を呼び出すことによって、直接

    (ソケットが作成されたプロセス) を除く noncontrolling プロセスのコンテキストで呼び出されます。

-   ハンドルの継承のメカニズムを使用してください。

    子プロセス (noncontrolling プロセス) は、その親プロセス (制御のプロセス) で作成したハンドルのすべてまたは一部を継承します。

-   正常な接続の終了時に

    制御のプロセスでアプリケーションでは、いくつかのデータが残って送信するときに、ソケットと終了を終了する場合、この残りのデータは Windows Sockets DLL にバッファリングされます。 System サービス プロセス (noncontrolling プロセス) のコンテキストで別のアプリケーション、その後このデータを送信します。

TCP/IP プロバイダーと組み合わせて、Windows Sockets スイッチは、検出し、上記の条件の各を処理します。 スイッチは、一度にデータを転送するか、基になる共有ソケットの状態を変更する操作を実行する 1 つだけのプロセスを許可します。 プロセスは、要求された操作を実行する、必要に応じて、基になるソケットのコントロールを動的にスワップします。 スイッチには、さまざまなプロセスは共有ソケット上で実行する要求し、最初に先出し (FIFO) の順序でこれらの操作を実行します。 操作がシリアル化します。 スイッチは、別のプロセスに、基になるソケットのコントロールをスワップする前に完了するすべての実行中の操作を待機します。 論理的には、スイッチでは、noncontrolling プロセスは、条件を満たす操作を要求すると、すぐに制御プロセスから基になるソケットのコントロールがかかります。 制御が奪わ後元の制御プロセスは、条件を満たす操作を要求した場合、スイッチ元の制御プロセス noncontrolling プロセスと同様に扱われます。 スイッチを取らないアクションで重複するソケットのハンドルを noncontrolling プロセスがデータ転送の状態を変更する操作の重複するソケット ハンドルを実際に使用されるまでに注意してください。

両方のスイッチと適切な SAN サービス プロバイダーは、特定の基になるソケットへのアクセスを共有するすべてのプロセスに読み込まれます。 スイッチでは、独自ソケット コンテキストと接続の状態情報、ソケットを共有するすべてのプロセスでは保持します。 SAN サービス プロバイダーが時間内の特定の時点の基になるソケットを制御するプロセスでのみソケット コンテキストと接続の状態情報を維持するために必要です。 SAN サービス プロバイダーは、スイッチでは、次の順序での説明に従って、スワップが必要とされるたびに、そのコンテキストと接続状態情報の現在の制御プロセスから次の制御プロセスにコントロールを交換する必要があります。 スワップするために必要なリソースの量を最小限に抑えるには、SAN サービス プロバイダーは、基になるソケットを共有するすべてのプロセスでそのコンテキストと接続の状態情報を維持できます。

スイッチは、アプリケーションでは、いずれかを呼び出すまで、アプリケーションのソケットに対応する SAN ソケットを作成していないため、**接続**または**リッスン**関数の場合、スイッチを要求することはできません、SANサービス プロバイダーは、アプリケーションのソケットを接続する前に、スワップ操作をリッスンしているかを実行します。 アプリケーションのソケットが接続されているまたはリッスンしている場合、次の条件のいずれか満たす必要がある、スイッチを要求する前に、SAN サービスをソケットのプロバイダーのスワップ コントロール。

-   ソケットを制御しませんプロセスは、データ転送を開始します。 制御プロセスによって開始されたすべてのデータ転送操作が完了するまで、SAN サービス プロバイダーはソケットのコントロールをスワップできません。

-   ソケットの呼び出しでは制御されませんプロセス、 **WSAAccept**、 **WSPAccept**、または**AcceptEx**リスナ ソケットで接続への同意操作を開始する関数。 すべて受け入れる制御プロセスによって開始された要求が完了するまで、SAN サービス プロバイダーはソケットのコントロールをスワップできません。

スイッチは、[次へ] を制御するプロセスに制御プロセスから接続されている SAN ソケットのコントロールをスワップする次の手順を実行します (概要については、スワップのプロセスは、表に関するドキュメントの「解説」を参照して、 [**WSPDuplicateSocket** ](https://msdn.microsoft.com/library/windows/hardware/ff566282)関数です。)。

1.  スイッチは、制御のプロセスで、アプリケーションから新しい要求の処理を中断します。 スイッチに SAN サービス プロバイダーの呼び出しすべての送信し、進行中の SAN のソケットでの RDMA の操作が完了、 [ **WSPSend** ](https://msdn.microsoft.com/library/windows/hardware/ff566316)が一時的に停止要求に接続されているピアにメッセージを送信する関数SAN サービスのプロバイダーのセッションと呼び出しの[ **WSPDeregisterMemory** ](https://msdn.microsoft.com/library/windows/hardware/ff566279)送信操作に使用されるすべてのローカル バッファーを解放する関数。 ピアの接続にあるスイッチが完了するには、SAN ソケット上で進行中の新しいアプリケーションの要求、すべての送信と RDMA の操作の待機処理を中断する結果として、および RDMA のすべてのメモリを解放します。 ピアの接続は、次に、セッションが中断されていることを示す応答メッセージを送信します。 この確認メッセージを受信するには、ローカル エンドポイントでスイッチに呼び出す SAN サービス プロバイダーの**WSPDeregisterRdmaMemory** RDMA のすべてのメモリを解放する関数。 この時点では、SAN のソケット接続の両方のエンドポイントにのみが要求を受信できる保留中です。 これらの要求を受け取る保留状態のまま、セッションの再アクティブ化を許可するリモート ピアの SAN のソケットでします。 次の手順では、制御のプロセスでのローカル、SAN ソケットの受信要求が完了しました。 接続が中断されている間、スイッチ、リモート ピア接続のキュー新しいブロックされているまたはオーバー ラップの要求でバッファーの新しい非ブロッキング送信をへ\_SNDBUF 設定、バッファー サイズの上限に達すると、新しい非ブロッキング送信が失敗して失敗したすべての新しい非ブロッキング WSAEWOULDBLOCK を受信します。 制御のプロセスで-local スイッチは、プロセスは、ソケットのコントロールがあるなかった場合、アプリケーションのソケットで新しい要求を処理します。

2.  スイッチに SAN サービス プロバイダーの呼び出し、セッションが中断された後**WSPDuplicateSocket**関数のアドレス空間にソケット コンテキストを転送する SAN サービス プロバイダーに出力するための制御のプロセスで、[次へ] を制御するプロセス。 スイッチで、[次へ] を制御するプロセスを指定します、 *dwProcessId*パラメーターの**WSPDuplicateSocket**します。 **WSPDuplicateSocket**関数を呼び出す必要があります、 **WPUCompleteOverlappedRequest**未処理のすべてを完了する関数が成功の状態とゼロ バイトのソケットでの要求を受信します。 SAN サービス プロバイダーは、これらの要求に関連付けられているすべてのバッファーをリリースも自動的にする必要があります。 スイッチは、SAN のソケットの後の操作を要求しないために、SAN サービス プロバイダーがすべてのバッファーを解放**WSPDuplicateSocket**を返します。 可能な唯一の例外は、 **WSPCloseSocket**関数の呼び出し、次の手順で説明されているようです。 後**WSPDuplicateSocket**返します、スイッチの値を保存する、 **dwProviderReserved** 、WSAPROTOCOL のメンバー\_INFOW 構造体、 *lpProtocolInfo*パラメーターが指すを出力します。 スイッチは、次の制御プロセスのコンテキストで基になるソケットを識別するためにこの値を使用します。 値ではそのため、 **dwProviderReserved**システム上のすべてのプロセスで基になるソケットと、ソケットの接続を識別する必要があります一意にします。 さらに、この値がでスイッチが指定されているプロセスのコンテキストでのみ有効にする必要があります、 *dwProcessId*パラメーターの**WSPDuplicateSocket**します。

3.  スイッチに SAN サービス プロバイダーの呼び出し-[次へ] を制御するプロセスのアドレス空間にソケット コンテキストが転送されると、 [ **WSPSocket** ](https://msdn.microsoft.com/library/windows/hardware/ff566319)制御 [次へ] のコンテキストで関数プロセスです。 この呼び出しでは、スイッチは基になるソケットで返された値を渡します、 **WSPDuplicateSocket**への呼び出し、 **dwProviderReserved** 、WSAPROTOCOL のメンバー\_INFOW。構造体、 *lpProtocolInfo*パラメーターが指すを入力します。 新しいソケットと呼び出しを SAN サービス プロバイダーを作成する必要があります-[次へ] を制御するプロセスが、SAN のソケットの作成を要求していない場合、 **WPUCreateSocketHandle**任意の新しいソケットを必要に応じて、ハンドルを取得する関数。 SAN ソケットは、次の制御プロセスのコンテキストで作成されている場合、SAN サービス プロバイダーは、前者のソケットを再アクティブ化し、以前を使用しているソケットの同じ記述子を返します。 ここでは、SAN サービス プロバイダーは呼び出す必要がありますいない**WPUCreateSocketHandle**がスイッチが提供される元のソケット ハンドルの使用を続行する必要があります。 また、SAN サービス プロバイダーは、かどうか、ソケット内の既存プロセスに関係なく、新しいソケットを作成できます。 この場合、スイッチは、SAN サービス プロバイダーを呼び出す必要があります[ **WSPCloseSocket** ](https://msdn.microsoft.com/library/windows/hardware/ff566273)前者ソケット記述子を破棄する-[次へ] を制御するプロセスのコンテキスト内の関数。

4.  スイッチは、次へ制御プロセス、アプリケーションから新しい要求の処理を再起動します。

スイッチは、スイッチがセッションを中断する必要がないことを除いて、同様の方法で待機中のソケットを複製します。 スイッチは、すべてが完了するまで待機する**WSPAccept**アプリケーションによって開始された呼び出し**受け入れる**と**AcceptEx** SAN サービスを呼び出す前に呼び出しプロバイダーの**WSPDuplicateSocket**制御プロセス内の関数。

スイッチ呼び出す前に、SAN のソケットで新しい要求の処理を中断するため、SAN サービスをプロバイダーの**WSPDuplicateSocket**関数の場合、SAN サービス プロバイダーがローカル エンドポイントと関連付けられているすべてのリソースを解放できます制御のプロセス。 SAN サービス プロバイダーは、基になる接続を終了もできます。 SAN サービス プロバイダーでは、制御のプロセスで基になる、接続を終了する場合、SAN サービス プロバイダーする必要があります接続を再確立、スイッチ、SAN サービス プロバイダーを呼び出してから**WSPSocket**関数内で、[次へ] を制御するプロセス。 後に、 **WSPSocket**呼び出しが戻る-[次へ] を制御するプロセス内にソケットを SAN、SAN でソケット制御プロセスが SAN サービスを呼び出して、切り替え前にスイッチの観点から、同じ状態である必要がありますプロバイダーの**WSPDuplicateSocket**関数。

受信する前に、制御のプロセスには、ローカル エンドポイントのリソースを解放する SAN サービス プロバイダーがない SAN NIC は、別のプロセスで実行されるエンドポイント間でリソースの共有をサポートする場合、 **WSPDuplicateSocket**呼び出します。 このような場合は、ローカル エンドポイントに関連付けられている SAN ソケット非アクティブのまま、以前の制御プロセスで、スイッチは、次の制御プロセスからソケット コンテキストを交換または SAN サービス プロバイダーの呼び出しまで**WSPCloseSocket**関数を明示的にソケットを閉じます。 ほとんどのアプリケーション プールを作成元であるプロセスでソケットへの最終的なアクセスを実行するため、一般に - 接続を閉じる、SAN サービス プロバイダー パフォーマンスを向上できます SAN サービス プロバイダーでソケット コンテキストを保持する場合、スイッチが、[次へ] を制御するプロセスのソケットのコントロールを交換した後は、プロセスを制御します。

、すべての場合、SAN のソケット記述子する必要がありますが有効である、スイッチ、SAN サービス プロバイダーを呼び出すまでに注意してください。 **WSPCloseSocket**関数を明示的にソケットを閉じます。 SAN サービス プロバイダー、ソケットを受信する前に特定のプロセスでのすべてのリソースを解放する場合でも、 **WSPDuplicateSocket**呼び出し、SAN サービス プロバイダー再利用しないでください、ソケットの記述子、スイッチを呼び出すまで**WSPCloseSocket**その記述子。

予期しないプロセスの終了時またはその他の何らかのエラー状態は、SAN サービス プロバイダーのソケットの複製操作を中断できます。 たとえば、リソース不足が原因には、このような中断を可能性があります。 スイッチは、このようなエラーを処理は、その他のエラー状況と条件します。 必要に応じて、スイッチは、ソケットの接続を強制的に終了するすべてのプロセスで基になるソケットに関連付けられているすべての記述子を閉じます。 リモート ピアの SAN サービス プロバイダーが完了する必要が可能であれば[ **WSPRecv** ](https://msdn.microsoft.com/library/windows/hardware/ff566309) WSAECONNRESET など、適切なエラー コードでデータを受信する呼び出し。 このエラー コードは、リモート ピアの接続終了を通知します。 リモート ピアにあるスイッチがこの接続終了を示す値を受信しない場合は、中断を要求したシステムが失敗した場合、リモート ピアにあるスイッチが中断されている接続をタイムアウトします。

 

 





