---
title: キーボードとマウスのクラス ドライバー
description: 非 HID キーボードとマウスは、複数のレガシ バス経由で接続しますが、引き続き同じクラス ドライバーを使用します。
ms.assetid: 0771D802-4F1D-4612-8376-ED3113DCC652
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: f29c31fae56bc7aac668d08854a40ee5bb55b5cb
ms.sourcegitcommit: a33b7978e22d5bb9f65ca7056f955319049a2e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 01/31/2019
ms.locfileid: "56578763"
---
# <a name="keyboard-and-mouse-class-drivers"></a>キーボードとマウスのクラス ドライバー


非 HID キーボードとマウスは、複数のレガシ バス経由で接続しますが、引き続き同じクラス ドライバーを使用します。 このセクションには、クラス ドライバー自体の詳細が含まれています。 次のセクションでは、コント ローラーの詳細に移動します。

このトピックでは、Microsoft Windows 2000 以降のキーボードとマウス デバイスの一般的な物理的な構成について説明します。

次の図は、1 つのキーボードとマウスを 1 回を採用している 2 つの一般的な構成を示しています。

![1 つのキーボードとマウスを 1 回を採用している 2 つの構成を示す図](images/kemocfg1.png)

左側の図は、キーボードとマウスの独立したコント ローラーを通じてシステム バスに接続されているを示します。 一般的な構成では、i8042 コント ローラーから操作 PS/2 スタイル キーボードとシリアル ポートのコント ローラーから操作シリアル スタイル マウスで構成されます。

次の追加情報がキーボードとマウスのメーカーにとって重要です。

-   キーボードは、セキュリティ上の理由から、オペレーティング システム スタックによって排他モードで開かれました。
-   Windows では、1 つ以上のキーボードとマウス デバイスの同時接続をサポートします。
-   Windows では、各デバイスにクライアントが独立したアクセスをサポートしません。

## <a name="class-driver-features"></a>クラス ドライバーの機能


このトピックでは、次の Microsoft Windows 2000 およびそれ以降のシステム クラス ドライバーの機能について説明します。

-   **Kbdclass**、GUID のデバイス用のクラス ドライバー\_クラス\_キーボード デバイス クラス

-   **Mouclass**、GUID のデバイス用のクラス ドライバー\_クラス\_マウス デバイス クラス

Kbdclass Kbdclass サービスを実装して、実行可能イメージは kbdclass.sys します。

Mouclass Mouclass サービスを実装して、実行可能イメージは mouclass.sys します。

Kbdclass と Mouclass 各機能。

-   デバイス クラスのジェネリックとハードウェアに依存しない操作。

-   プラグ アンド プレイ、電源管理、および Windows Management Instrumentation (WMI)。

-   レガシ デバイスの操作です。

-   1 つ以上のデバイスの同時操作です。

-   接続、[サービス コールバック ルーチンをクラス](https://msdn.microsoft.com/library/windows/hardware/ff542274)クラス ドライバーのデータ バッファーにデバイスの入力バッファーからデータを転送する機能ドライバーを使用しています。

## <a name="configuration-of-device-objects"></a>デバイス オブジェクトの構成


次の図は、プラグ アンド プレイ PS/2 形式のキーボードとマウス デバイスのデバイス オブジェクトの構成を示します。 各クラス ドライバーは、上位のクラスを作成します。*フィルター デバイス オブジェクト*(フィルターの操作) 関数のデバイス オブジェクトに関連付けられている (*FDO*) オプションの上位レベルのデバイスでフィルター操作を行います。 上位レベルのデバイスのフィルター ドライバーでは、上位レベルのデバイスのフィルターは作成します。 I8042prt DO 関数を作成して、物理デバイス オブジェクトにアタッチします (*PDO*) ルート バス ドライバーによって作成します。

![プラグ アンド プレイ ps/2 スタイル キーボードとマウス デバイスのデバイス オブジェクトの構成を示す図](images/km-ovr2.png)

*Ps/2 キーボード*

キーボードのドライバー スタックは、以下の構成します。

-   Kbdclass、上位レベルのキーボード クラス フィルター ドライバー
-   1 つまたは複数の上位レベルの省略可能なキーボード フィルター ドライバー
-   I8042prt、関数のドライバー

*Ps/2 マウス*

マウスのドライバー スタックは、以下の構成します。

-   Mouclass、マウスの上位レベルのクラスのフィルター ドライバー
-   1 つまたは複数の上位レベルのマウス (オプション) フィルター ドライバー
-   I8042prt、関数のドライバー

Kbdclass と Mouclass は、2 つの異なるモードで、1 つ以上のデバイスをサポートすることができます。 *一対一モード*、各デバイスには、独立したデバイス スタック。 クラスのドライバーでは、作成し、各デバイス スタックには独立したクラスを結び付けます。 各デバイス スタックは、独自のコントロールの状態と入力バッファーがあります。 Microsoft Win32 サブシステムでは、一意のファイル オブジェクトを通じて各デバイスからの入力にアクセスします。

*最強モード*、クラス ドライバーでは、次のように、すべてのデバイスが動作します。

-   クラス ドライバーには、両方が作成され、*最強クラスは*を表すすべてのデバイスと*下位クラスは*デバイスごとに。

    クラス ドライバーは、各デバイス スタックには下位のクラスをアタッチします。 下位のクラスは、次は、デバイス スタックは、一対一のモードで作成と同じです。

-   最強クラスは、下位のすべての DOs の操作を制御します。

-   Win32 サブシステムでは、最強のクラスのデバイスを表すファイル オブジェクトを介してデバイスのすべての入力にアクセスします。

-   すべてのデバイス最強のデータ キューの入力バッファーに保存します。

-   最強では、1 つのグローバル デバイスの状態を維持します。

場合の一対一のモードで Kbdclass と Mouclass が動作のレジストリ エントリ値**ConnectMultiplePorts** 0x00 に設定されている (キーの下**HKLM\\サービス\\CurrentControlSet\\ ***&lt;サービス クラス&gt;***\\パラメーター**ここで、*サービス クラス*Kbdclass または Mouclass)。 それ以外の場合 Kbdclass と Mouclass 最強のモードで動作します。

## <a name="open-and-close-via-the-class-driver"></a>クラスのドライバーを経由して開閉


Microsoft Win32 サブシステムでは、すべてのキーボードとマウス デバイスを排他的に使用が開きます。 各デバイス クラスの Win32 サブシステムは、1 つの入力デバイスからの入力が組み込まれていた場合、すべてのデバイスからの入力を扱います。 1 つだけ特定のデバイスからの入力を受信するアプリケーションを要求できません。

プラグ アンド プレイ manager から通知を受け取た後入力デバイスのプラグ アンド プレイが Win32 サブシステムによって動的に開いたりする GUID\_クラス\_キーボードまたは GUID\_クラス\_マウス デバイス インターフェイス有効になります。 Win32 サブシステムは、開かれているインターフェイスが無効である通知を受信した後に、プラグ アンド プレイ デバイスを閉じます。 Win32 サブシステムが名前でも従来のデバイスを開きます (たとえば、"\\デバイス\\KeyboardLegacyClass0")。 Win32 サブシステムでは、従来のデバイスが正常に開かれたとを特定できないかどうか、デバイスは削除後で物理的に注意してください。

Kbdclass と Mouclass 受信要求の作成後に次のプラグ アンド プレイと従来の操作、操作を行います。

-   **プラグ アンド プレイ操作**

    クラスのドライバーが IRP を送信する場合は、デバイスのプラグが再生開始状態、\_MJ\_ドライバー スタック ダウン要求を作成します。 それ以外の場合、クラス ドライバーは、ドライバー スタック ダウン要求を送信することがなく、要求を完了します。 クラスのドライバーでは、デバイスへの読み取りアクセス権を持つ信頼されたファイルを設定します。 最強のデバイスがある場合、クラス ドライバーは下位のクラスのデバイスに関連付けられているすべてのポートを作成要求を送信します。

-   **従来の操作**

    クラス ドライバーは、デバイスを有効にするポート ドライバーに内部デバイスの制御要求を送信します。

## <a name="connect-a-service-callback-to-a-device"></a>サービスのコールバックをデバイスに接続します。


デバイスを開く前に、クラス ドライバーはそのクラスのサービスをデバイスに接続する必要があります。 クラス ドライバーは、デバイス スタックにもクラスは、アタッチした後、そのクラスのサービスを接続します。 関数ドライバーでは、クラスのサービスのコールバックを使用して、デバイスのクラスのデータのキューへのデバイスから入力データを転送します。 デバイスの機能のドライバーの ISR ディスパッチ完了ルーチンでは、クラスのサービスのコールバックを呼び出します。 クラスのサービスのコールバックを提供する Kbdclass [ **KeyboardClassServiceCallback**](https://msdn.microsoft.com/library/windows/hardware/ff542324)、Mouclass クラスのサービスのコールバックを提供して[ **MouseClassServiceCallback**](https://msdn.microsoft.com/library/windows/hardware/ff542394).

仕入先は、デバイス用の上位レベルのフィルター ドライバーをインストールすることでクラス サービスのコールバックの動作を変更することができます。 サンプルのフィルター ドライバー [Kbfiltr](https://go.microsoft.com/fwlink/p/?linkid=256125)定義、 [ **KbFilter\_ServiceCallback** ](https://msdn.microsoft.com/library/windows/hardware/ff542297)コールバック、およびフィルター ドライバーのサンプル[Moufiltr](https://go.microsoft.com/fwlink/p/?linkid=256135)定義、 [ **MouFilter\_ServiceCallback** ](https://msdn.microsoft.com/library/windows/hardware/ff542380)コールバック。 デバイスのポートの入力バッファーからクラスのデータ キューに転送される入力データを変更するのには、サンプル フィルター サービスのコールバックを構成できます。 たとえば、フィルター サービスのコールバックできます削除、変換、またはデータを挿入します。

次のようには、サービスのクラスとフィルターのコールバックが接続されています。

-   クラス ドライバー内部のデバイスの送信接続デバイス スタックの要求 ([**IOCTL\_内部\_キーボード\_CONNECT** ](https://msdn.microsoft.com/library/windows/hardware/ff541279)または[ **IOCTL\_内部\_マウス\_CONNECT**](https://msdn.microsoft.com/library/windows/hardware/ff541300))。 クラスは、データを接続する接続で指定された\_クラスのデバイス オブジェクトへのポインターとクラスのサービスのコールバックへのポインターを含むデータ構造体。

-   フィルター ドライバーが接続要求を受信した後、クラスの connect のデータのコピーを保存し、要求の接続のデータを接続データをフィルター処理に置き換えます。 フィルター データを接続する、フィルター デバイス オブジェクトへのポインターと、フィルター ドライバー サービス コールバックへのポインターを指定します。 次に、フィルター ドライバーは、関数のドライバーをフィルター選択された接続要求を送信します。

次のように、サービスのクラスとフィルターのコールバックが呼び出されます。

-   関数のドライバーは、フィルターは、フィルター サービスのコールバックを初期のコールバックを有効にするデータを接続します。

-   入力データをフィルター処理した後、フィルター サービスがコールバック使用クラスは、データ接続クラスのサービスのコールバックをコールバックする保存されています。

## <a name="query-and-set-a-keyboard-device"></a>クエリを実行し、キーボード デバイスを設定


I8042prt には、キーボード デバイスのパラメーターを設定して、キーボード デバイスに関する情報を照会する次の内部デバイス制御の要求がサポートされています。

[**IOCTL\_キーボード\_クエリ\_属性**](https://msdn.microsoft.com/library/windows/hardware/ff541325)

[**IOCTL\_キーボード\_クエリ\_インジケーター\_翻訳**](https://msdn.microsoft.com/library/windows/hardware/ff541352)

[**IOCTL\_キーボード\_クエリ\_インジケーター**](https://msdn.microsoft.com/library/windows/hardware/ff541337)

[**IOCTL\_キーボード\_クエリ\_キーボード**](https://msdn.microsoft.com/library/windows/hardware/ff541357)

[**IOCTL\_キーボード\_設定\_インジケーター**](https://msdn.microsoft.com/library/windows/hardware/ff542059)

[**IOCTL\_キーボード\_設定\_キーボード**](https://msdn.microsoft.com/library/windows/hardware/ff542070)

キーボード デバイス コントロールのすべての要求に関する詳細については、[I8042prt キーボード内部デバイス制御要求](https://msdn.microsoft.com/library/windows/hardware/ff539973)を参照してください。

## <a name="scan-code-mapper-for-keyboards"></a>コードのマッパーのキーボードをスキャンします。


Microsoft Windows オペレーティング システムでは、入力デバイスによって提供される PS/2 と互換性のあるスキャン コードが仮想キーは、Windows メッセージの形式でシステムを介して反映されますに変換されます。 デバイスは、特定のキーの不適切なスキャン コードを生成、間違った仮想キーのメッセージが送信されます。 これは、ファームウェアによって生成されるスキャン コードを分析し、システムで認識されるいずれかに不適切なスキャン コードを変更するフィルター ドライバーを記述することで修正できます。 ただし、これは面倒なプロセスです、カーネル レベルのフィルター ドライバーにエラーが存在しない場合、深刻な問題を招くことができますもあります。

Windows 2000 および Windows XP には、新しいスキャン コード-マッパー、スキャン コードのマッピングを可能にするメソッドを提供するが含まれます。 Windows のスキャン コードのマッピングは、次のレジストリ キーに格納されます。

``` syntax
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Keyboard Layout
```

**注**  も、**キーボード レイアウト**キー (複数形に注目してください)、コントロールのキーがそのキーを変更しないでください。

 

**キーボード レイアウト**キー、 **Scancode マップ**値を追加する必要があります。 この値が型 REG\_バイナリ (little Endian 形式) し、次の表のデータ形式を指定します。

|                         |                 |                              |
|-------------------------|-----------------|------------------------------|
| 開始オフセット (バイト) を | サイズ (バイト単位) | データ                         |
| 0                       | 4               | ヘッダー:バージョン情報  |
| 4                       | 4               | ヘッダー:フラグ                |
| 8                       | 4               | ヘッダー:マッピングの数   |
| 12                      | 4               | 個別のマッピング           |
| ...                     | ...             | ...                          |
| 最後の 4 バイト            | 4               | Null ターミネータ (0x00000000) |

 

最初と 2 つ目の DWORD では、ヘッダー情報を保存し、コードのスキャン マッパーの現在のバージョンのすべてのゼロに設定する必要があります。 3 番目の DWORD エントリには、null 終端のマッピングを含むマッピングの合計数のカウントを保持します。 最小数は、1 (マッピングが指定した) ためでしょう。 個別のマッピングでは、ヘッダーに従います。 各マッピングの長さの 1 つの DWORD であり、2 つの単語の長さのフィールドに分かれています。 WORD の各フィールドは、マップするキーのスキャン コードを格納します。

マップは、レジストリに格納されると、マッピングを有効にするのシステムを再起動する必要があります。 スキャン コードのマッピングが keypress に必要な場合、手順が実行をユーザー モードでスキャン コードが仮想キーに変換する前に注意してください。 ユーザー モードでは、この変換を行うと、ターミナル サービスで実行されているときに正しく動作しないマッピングなどの特定の制限事項を表示できます。

これらのマッピングを削除するには、Scancode マップのレジストリ値を削除し、再起動します。

*例 1*

例を次に示します。 CAPS LOCK キーを持つ左 CTRL キーを交換するには、レジストリ エディター (Regedt32.exe 可能であれば) を使用して、次の値を持つ Scancode マップ キーを変更します。

``` syntax
00000000 00000000 03000000 3A001D00 1D003A00 00000000
```

次の表には、これらのエントリ DWORD フィールドとスワップ (バイト) に分割にはが含まれています。

|            |                                                    |
|------------|----------------------------------------------------|
| [値]      | 解釈                                     |
| 0x00000000 | ヘッダー:[バージョン] の横の数字を確認します。 すべてゼロに設定します。                |
| 0x00000000 | ヘッダー:フラグを設定します。 すべてゼロに設定します。                  |
| 0x00000003 | マップ (null のエントリを含む) の 3 つのエントリ。   |
| 0x001D003A | 左 CTRL キーを--&gt; CAPS LOCK (0x1D--&gt; 0x3A)。 |
| 0x003A001D | CAPS LOCK--&gt;左 CTRL キー (0x3A--&gt; 0x1D)。 |
| 0x00000000 | Null 終端文字。                                   |

 

*例 2*

キーボードで一般的に使用可能なキーを追加するか、使用されていません。 キーを削除することもできます。 次の例に格納されている値が表示されます。 **Scancode マップ**右 CTRL キーを削除すると、ミュート キーとして機能する左右の ALT キーの機能を変更します。

``` syntax
00000000 00000000 03000000 00001DE0 20E038E0 00000000
```

次の表には、これらのエントリ DWORD フィールドとスワップ (バイト) に分割にはが含まれています。

|            |                                                       |
|------------|-------------------------------------------------------|
| [値]      | 解釈                                        |
| 0x00000000 | ヘッダー:[バージョン] の横の数字を確認します。 すべてゼロに設定します。                   |
| 0x00000000 | ヘッダー:フラグを設定します。 すべてゼロに設定します。                     |
| 0x00000003 | マップ (null のエントリを含む) の 3 つのエントリ。      |
| 0xE01D0000 | 右 CTRL キーを削除 (0xE01D--&gt; 0x00)。       |
| 0xE038E020 | 右 ALT キー--&gt;ミュート キー (0xE038--&gt; 0xE020)。 |
| 0x00000000 | Null 終端文字。                                      |

 

必要なデータが生成された後は、いくつかの方法でレジストリに挿入できます。

-   .Reg ファイルを生成できるレジストリ エディターを使用して、システム レジストリに簡単に組み込むです。
-   .Inf ファイルを作成することも、 \[AddReg\]セクションを追加するためにレジストリ情報が含まれています。
-   Regedt32.exe は、レジストリに情報を手動で追加できます。

コードのスキャン マッパーでは、いくつかの長所と短所が。

利点があります。

-   マッパーは、ファームウェア エラーを修正する簡単な修正として使用できます。
-   頻繁に使用されるキーは、レジストリ内のマップを変更することで、キーボードに追加できます。 (たとえば、CTRL キーを適切な) 使用されていない多くの場合、キーは、null (削除) にマップされているまたはその他のキーの交換できます。
-   キーの場所を簡単に変更することができます。 ユーザーは自分の特典を頻繁に使用されるキーの場所を簡単にカスタマイズできます。

次のようなデメリットが認識されます。

-   マップがレジストリに保存されると、アクティブ化するシステムの再起動が必要です。
-   レジストリに格納されているマッピングでは、システム レベルで動作し、すべてのユーザーに適用します。 これらのマッピングは、現在のユーザーによって動作が異なりますに設定することはできません。
-   現在の実装は、マッピングは、常に、システムに接続されているすべてのキーボードに適用されるように、マップの機能を制限します。 現在では、キーボードあたりごとに、マップを作成することはできません。

## <a name="query-a-mouse-device"></a>マウス デバイスのクエリ


I8042prt には、マウス デバイスに関する情報を照会は、次のデバイスの内部コントロール要求がサポートされています。

[**IOCTL\_マウス\_クエリ\_属性**](https://msdn.microsoft.com/library/windows/hardware/ff542085)

マウス デバイス コントロールのすべての要求に関する詳細については、[I8042prt マウス内部デバイス制御要求](https://msdn.microsoft.com/library/windows/hardware/ff539982)を参照してください。

## <a name="registry-settings-associated-with-mouse-class-driver"></a>マウスのクラス ドライバーに関連するレジストリ設定


次にマウスのクラス ドライバーに関連付けられているレジストリ キーの一覧を示します。

\[キー:HKLM\\システム\\CurrentControlSet\\サービス\\Mouclass\\パラメーター\]

-   MaximumPortsServiced – Windows XP 以降が使用されません。 Windows NT4 には。
-   PointerDeviceBaseName – マウス クラスのデバイス ドライバーによって作成されたデバイス オブジェクトの基本名を指定します
-   ConnectMultiplePorts – は、各クラスのデバイス オブジェクトのデバイス オブジェクトを 1 つのポートより 1 つ以上があるかどうかを判断します。 このエントリは、主にデバイス ドライバーによって使用されます。
-   MouseDataQueueSize - には、マウスのドライバーによってバッファリング マウス イベントの数を指定します。 これはまた、非ページ メモリ プールでのマウス ドライバーの内部バッファーのサイズの計算で使用されます。

追加の詳細については、それぞれ特定のレジストリ キーがでご確認いただけます https://technet.microsoft.com

## <a name="absolute-pointing-devices"></a>絶対ポインティング デバイス


GUID 型のデバイスの\_クラス\_マウス デバイスの機能のドライバー。

-   デバイス固有の入力を処理します。

-   作成、 [**マウス\_入力\_データ**](https://msdn.microsoft.com/library/windows/hardware/ff542403)構造体に必要な[ **MouseClassServiceCallback**](https://msdn.microsoft.com/library/windows/hardware/ff542394)します。

-   マウスを転送\_入力\_データ構造を呼び出すことによって、Mouclass データ キュー **MouseClassServiceCallback**その ISR で完了ルーチンをディスパッチします。

デバイスの機能のドライバーを設定する必要があります絶対ポインティング デバイスの場合、 **LastX**、**最後**と**フラグ**、マウスのメンバー\_入力\_次のようにデータ構造体。

-   デバイスの最大の機能によって、デバイスの入力値を分割する以外は、ドライバーは、0 xffff によってデバイスの入力値のスケールを設定します。

    ```cpp
    LastX = ((device input x value) * 0xFFFF ) / (Maximum x capability of the device)
    LastY = ((device input y value) * 0xFFFF ) / (Maximum y capability of the device)
    ```

-   ドライバーの設定、マウス\_移動\_絶対フラグ**フラグ**します。

-   ドライバーが、マウスを設定する場合は、入力が全体の仮想デスクトップ ウィンドウ マネージャーによってをマップする必要があります、\_仮想\_デスクトップ フラグ**フラグ**します。 場合、マウス\_仮想\_デスクトップ フラグが設定されていない、ウィンドウ マネージャーは、プライマリ モニターのみへの入力をマップします。

次を指定して、デバイスの種類で絶対のポインティング デバイスに対するこれらの特別な要件を実装する方法。

-   HID デバイス:

    Mouhid、HID マウス デバイス、Windows 機能のドライバーでは、これらの特別な要件が自動的に実装します。

-   PS/2 形式のデバイス:

    上位レベルのフィルター ドライバーが必要です。 フィルター ドライバーは、IsrHook コールバックとクラス サービスのコールバックを提供します。 I8042prt では、ロウ デバイスの入力を処理する IsrHook を呼び出し、入力をフィルター処理するには、フィルター クラス サービス コールバックを呼び出します。 フィルター クラスのサービス コールバックが呼び出されます、 **MouseClassServiceCallback**します。 IsrHook コールバックとクラスのサービスのコールバックの組み合わせがデバイスに固有の入力を処理、必要なマウスを作成します\_入力\_データ構造体のデバイスの入力データをスケーリングし、マウスを設定\_の移動。\_絶対フラグ。

-   Serenum で列挙されているプラグ アンド プレイ COM ポートのデバイス:

    プラグ アンド プレイ機能のドライバーが必要です。 関数のドライバーが必要なマウスを作成します\_入力\_データ構造体のデバイスの入力データをスケーリングし、マウスを設定\_移動\_を呼び出す前に、絶対フラグ**MouseClassServiceCallback**.

-   非プラグ アンド プレイの COM ポートのデバイス:

    デバイス固有の関数のドライバーが必要です。 関数のドライバーが必要なマウスを作成します\_入力\_データ構造体のデバイスの入力データをスケーリングし、マウスを設定\_移動\_を呼び出す前に、絶対フラグ**MouseClassServiceCallback**.

-   サポートされていないバス上のデバイス:

    デバイス固有の関数のドライバーが必要です。 関数のドライバーが必要なマウスを作成します\_入力\_データ構造体のデバイスの入力データをスケーリングし、マウスを設定\_移動\_を呼び出す前に、絶対フラグ**MouseClassServiceCallback**.

 

 




