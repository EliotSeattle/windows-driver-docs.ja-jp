---
title: コンテキストの変更
description: コンテキストの変更
ms.assetid: 3690903c-4281-4c65-98b0-00ca22206168
keywords:
- コンテキスト
- logon session, context
- コンテキスト、セッションのコンテキスト
- セッション、コンテキスト
- ユーザー セッション
- セッション
ms.date: 08/02/2018
ms.localizationpriority: medium
ms.openlocfilehash: 6492c81235a35617a06c52dc8d7982d0789b99c9
ms.sourcegitcommit: 0cc5051945559a242d941a6f2799d161d8eba2a7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "63376101"
---
# <a name="changing-contexts"></a>コンテキストの変更


## <span id="ddk-changing-contexts_dbg"></span><span id="DDK_CHANGING_CONTEXTS_DBG"></span>


カーネル モードのデバッグでは多くのプロセス、スレッド、および同時に実行しているユーザー セッション場合があります。 「仮想アドレス 0x80002000」などのため、語句または"、 **eax**登録"はあいまいです。 指定する必要があります、*コンテキスト*でこのようなフレーズを認識できます。

デバッガーには、デバッグ中に設定できる 5 つの異なるコンテキストがあります。

1.  セッションのコンテキストでは、既定のユーザー セッションを示します。 

2.  プロセスのコンテキストでは、デバッガーでの仮想アドレスの解釈方法を決定します。

3.  *ユーザー モード アドレス コンテキスト*直接設定はほとんどありません。 プロセスのコンテキストを変更すると、このコンテキストは自動的に設定します。

4.  レジスタのコンテキストでは、デバッガーでレジスタを解釈する方法やもスタック トレースの結果を制御する方法を決定します。 このコンテキストとも呼ばれますが、*スレッド コンテキスト*その用語は完全に正確ではありませんが、します。 *コンテキストの明示的な*レジスタのコンテキストの型になります。 コンテキストの明示的なを指定すると、現在のレジスタのコンテキストではなく、そのコンテキストが使用されます。

5.  ローカル コンテキストでは、ローカル変数がデバッガーでどのように解釈されるかを決定します。 このコンテキストとも呼ばれますが、*スコープ*します。

### <a name="span-idsession-contextspanspan-idsessioncontextspansession-context"></a><span id="session-context"></span><span id="SESSION_CONTEXT"></span>セッション コンテキスト

複数のログオン セッションを同時に実行できます。 ログオン セッションごとに独自のプロセスがあります。

[ **! セッション**](-session.md)拡張機能は、すべてのログオン セッションを表示します。 または、現在のセッション コンテキストを変更します。

セッション コンテキストを使って、 [ **! sprocess** ](-sprocess.md)と[ **! spoolused** ](https://msdn.microsoft.com/library/windows/hardware/ff565361) 「-2」としてセッション数が入力したときに拡張機能。

セッション コンテキストが変更されたときにプロセスのコンテキストは、アクティブなプロセスにセッションに自動的に変更されます。

### <a name="span-idprocess-contextspanspan-idprocesscontextspanprocess-context"></a><span id="process-context"></span><span id="PROCESS_CONTEXT"></span>プロセス コンテキスト

各プロセスが仮想のアドレスを記録する独自のページ ディレクトリの物理アドレスにマップされます。 プロセス内で任意のスレッドを実行しているときに、Windows オペレーティング システムは仮想アドレスを解釈するのにこのページのディレクトリを使用します。

ユーザー モードでは、デバッグ時に、現在のプロセスは、プロセスのコンテキストを決定します。 デバッガー コマンド、拡張機能、および windows が現在のプロセスのページのディレクトリを使用して解釈されるデバッグ情報で使用されている仮想アドレス。

使用してプロセスのコンテキストを設定する、カーネル モードのデバッグ時に、 [ **.process (プロセス コンテキストの設定)** ](-process--set-process-context-.md)コマンド。 このコマンドを使用すると、どのプロセスのページのディレクトリが仮想アドレスを解釈に使用を選択できます。 プロセスのコンテキストを設定した後は、アドレスを受け取る任意のコマンドでこのコンテキストを使用することができます。 このアドレスにもブレークポイントを設定することができます。 含めることによって、 **/i**オプション、 **.process**な侵襲性デバッグを指定するコマンド、ユーザー領域でブレークポイントを設定する、カーネル デバッガーを使用することもできます。

カーネル領域関数をプロセスに固有のブレークポイントを使用してカーネル デバッガーからユーザー モードのブレークポイントを設定することもできます。 戦略的なブレークポイントを設定し、適切なコンテキストを待機します。

*ユーザー モード アドレス コンテキスト*はプロセスのコンテキストの一部です。 通常、ユーザー モード アドレスのコンテキストを直接設定するのにはありません。 プロセスのコンテキストを設定すると、ユーザー モード アドレス コンテキストは自動的にプロセスに関連するページのテーブルのベース ディレクトリに変更します。 

カーネル モードのデバッグ中にプロセスのコンテキストを設定すると、そのプロセスのコンテキストが別まで保持されます。 **.process**コマンドは、コンテキストを変更します。 ユーザー モード アドレスのコンテキストにもまで保持されます、 **.process**または **.context**コマンドに変更します。 対象のコンピュータを実行して、レジスタのコンテキストまたはローカル コンテキストの変更により影響は受けませんときに、これらのコンテキストは変更されません。

### <a name="span-idregister-contextspanspan-idregistercontextspanregister-context"></a><span id="register-context"></span><span id="REGISTER_CONTEXT"></span>コンテキストに登録します。

各スレッドは、独自のレジスタの値を持っています。 これらの値は、スレッドを実行するときに、CPU レジスタに格納されているし、別のスレッドを実行するときにメモリに格納されます。

通常、現在のスレッドでは、ユーザー モードのデバッグ時に、レジスタのコンテキストが決まります。 デバッガー コマンド、拡張機能、およびデバッグ情報のウィンドウでのレジスタへの参照は現在のスレッドのレジスタに従って解釈されます。

次のコマンドのいずれかを使用してユーザー モードのデバッグを実行している間、現在のスレッド以外の値にレジスタのコンテキストを変更できます。

[**.cxr (コンテキスト レコードの表示)**](-cxr--display-context-record-.md)

[**.ecxr (例外コンテキスト レコードの表示)**](-ecxr--display-exception-context-record-.md)

カーネル モードのデバッグは、中には、次のコマンドを含むデバッガー コマンドを使用して、レジスタのコンテキストを制御できます。

[**.thread (レジスタのコンテキストの設定)**](-thread--set-register-context-.md)

[**.cxr (コンテキスト レコードの表示)**](-cxr--display-context-record-.md)

[**.trap (表示トラップ フレーム)**](-trap--display-trap-frame-.md)

これらのコマンドでは、CPU レジスタの値は変更されません。 代わりに、デバッガーは、メモリ内の場所から指定されたレジスタのコンテキストを取得します。 実際には、デバッガーはのみを取得できます、*保存*レジスタの値。 (その他の値は、動的に設定されは保存されません。 保存されている値はスタック トレースを再作成するには不十分です。

レジスタの値をなどを使用するすべてのコマンド新しい登録コンテキストが使用されるレジスタのコンテキストを設定すると、 [ **k (Display Stack Backtrace)** ](k--kb--kc--kd--kp--kp--kv--display-stack-backtrace-.md)と[ **r (レジスタ)**](r--registers-.md).

ただし、マルチプロセッサ コンピューターをデバッグするときにいくつかのコマンドを有効にするプロセッサを指定することです。 (このようなコマンドの詳細については、次を参照してください[マルチプロセッサ構文](multiprocessor-syntax.md)。)。コマンド プロセッサを指定する場合、コマンドは場合でも、指定されたプロセッサは、現在アクティブなプロセッサ、レジスタの現在のコンテキストではなく、指定されたプロセッサ上のアクティブなスレッドの登録コンテキストを使用します。

また、レジスタのコンテキストで、現在のプロセッサ モードの設定が一致しない場合これらのコマンドは、正しくないか、意味のない出力を生成します。 出力エラーを避けるためには、レジスタの状態に依存するコマンドは、レジスタのコンテキストに合わせてプロセッサ モードを変更するまで失敗します。 プロセッサ モードを変更するには、使用、 [ **.effmach (効果的な Machine)** ](-effmach--effective-machine-.md)コマンド、

レジスタのコンテキストを変更すると、ローカル コンテキストも変更できます。 この方法でレジスタのコンテキストのローカル変数の表示に影響します。

かどうか、アプリケーションの実行をステップ実行、またはトレースが発生した、レジスタのコンテキストが直ちにプログラム カウンターの位置に一致するようにリセットします。 ユーザー モードで、レジスタのコンテキストは、現在のプロセスまたはスレッドが変更された場合もリセットされます。

レジスタのコンテキスト スタック トレースを開始位置のスタック ポインター レジスタをために、スタック トレースに影響 (**esp** x86 ベースのプロセッサ上) を指します。 レジスタのコンテキストが無効であるかアクセスできない値に設定されている場合は、スタック トレースを取得できません。

プロセッサのブレークポイント (データ ブレークポイント) を特定のレジスタのコンテキストに適用するにを使用して、 [ **.apply\_dbp (適用データ ブレークポイントのコンテキストに)** ](-apply-dbp--apply-data-breakpoint-to-context-.md)コマンド。

### <a name="span-idlocal-contextspanspan-idlocalcontextspanlocal-context"></a><span id="local-context"></span><span id="LOCAL_CONTEXT"></span>ローカル コンテキスト

プログラムを実行しているときに、ローカル変数の意味で定義されている関数にのみこのような変数のスコープを拡張するため、プログラム カウンターの場所に依存します。

ユーザー モードまたはカーネル モードのデバッグを実行している場合は、デバッガーはローカル コンテキストと現在の関数 (スタック上の現在のフレーム) のスコープを使用します。 このコンテキストを変更するには、使用、 [ **.frame (ローカル コンテキストの設定)** ](-frame--set-local-context-.md)コマンド、またはで目的のフレームをダブルクリックして、[コール スタック ウィンドウ](calls-window.md)します。

ユーザー モードのデバッグは、使用するローカル コンテキストとは、常に現在のスレッドのスタック トレース内のフレームです。 カーネル モードのデバッグには、ローカル コンテキストと、レジスタの現在のコンテキストのスレッドのスタック トレース内のフレームでは常にします。

ローカル コンテキストでの時刻に 1 つだけのスタック フレームを使用できます。 他のフレームのローカル変数にアクセスできません。

ローカル コンテキストは、次のイベントのいずれかが発生した場合にリセットされます。

-   すべてのプログラムの実行ステップまたはトレース

-   どのように使用される任意のコマンドでスレッド区切り記号 (~)

-   レジスタのコンテキストに何らかの変更します。

[ **! の\_各\_フレーム**](-for-each-frame.md)拡張機能では、1 つのコマンドを繰り返し実行、1 回の各フレームのスタックにすることができます。 このコマンドは、各フレームのローカルのコンテキストを変更する、指定のコマンドを実行し、元の値に、ローカル コンテキストを返します。

 

 





