---
title: MASM の式とC++ の式
description: MASM の式と
ms.assetid: 3ec06b61-9f17-49b1-b7c5-66a349b5d275
keywords:
- C++、MASM 式
- MASM の vs での MASM 式。C++
- C++ 式では、C++ とします。MASM
ms.date: 05/23/2017
ms.localizationpriority: medium
ms.openlocfilehash: dc1d4670e112e5b0c33ddcc1bb95d41093d7fe96
ms.sourcegitcommit: 0cc5051945559a242d941a6f2799d161d8eba2a7
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/23/2019
ms.locfileid: "63383298"
---
# <a name="masm-expressions-vs-c-expressions"></a>MASM の式とC++ の式


## <span id="ddk_masm_expressions_vs__c_expressions_dbg"></span><span id="DDK_MASM_EXPRESSIONS_VS__C_EXPRESSIONS_DBG"></span>


MASM の式の評価と C++ の式の評価の最も重要な違いは次のとおりです。

-   MASM 式では、任意のシンボルの数値は、そのメモリ アドレスです。 C++ の式では、変数の数値は、そのアドレスではなく、実際の値です。 データ構造には、数値の値はありません。 代わりに、実際の構造体として扱われ、それに応じて使用する必要があります。 関数名または他のエントリ ポイントの値は、メモリ アドレスが、関数ポインターとして扱われます。 (変更されていないモジュール名) などの C++ データ型に対応していないシンボルを使用する場合は、構文エラーが発生します。

-   MASM の式エバリュエーターでは、ULONG64 値としてすべての数値を処理します。 C++ の式エバリュエーターでは、ULONG64 を数値にキャストし、すべてのデータ型の型情報を保持します。

-   MASM の式エバリュエーターでは、任意の数と共に任意の演算子を使用することができます。 C++ の式エバリュエーターは、不適切なデータ型と演算子を使用する場合、エラーを生成します。

-   MASM 式エバリュエーターでは、文字どおりすべての算術演算が行われます。 C++ の式エバリュエーターでは、ポインターの算術演算が正しくスケールし、不適切な場合は許可されません。

-   MASM 式は、2 つのアンダー スコアを使用できます ( **\_ \_** ) または 2 つのコロン ( **::** ) をクラスのメンバーを示します。 C++ の式エバリュエーターでは、2 つのコロンの構文のみを使用します。 デバッガー*出力*常に 2 つのコロンを使用します。

-   追加する必要があります、MASM 式で、アット マーク (**@**) する前に、最も一般的なレジスタ以外のすべて。 サインインでこれを省略した場合は、シンボル、または 16 進数として、レジスタ名が解釈可能性があります。 C++ の式では、このプレフィックスは、すべてのレジスタ必要があります。

-   MASM の式には、ソース行への参照が含まれます。 これらの参照はグレーブ アクセント記号で示されます ( **\`** )。 C++ の式でソース行番号を参照することはできません。

 

 





