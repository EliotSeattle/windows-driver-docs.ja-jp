---
title: バッファー処理
description: バッファー処理
ms.assetid: 0739ff35-2915-4237-9fe0-11559eccb0bb
keywords:
- セキュリティ WDK ファイルシステム、脅威の最小化
- WDK ファイルシステムのバッファー
- ページバッファー WDK ファイルシステム
- 非ページバッファー WDK ファイルシステム
- WDK ファイルシステムのバグチェック
- 検証 WDK ファイルシステム
- 高速 i/o WDK ファイルシステム
ms.date: 04/20/2017
ms.localizationpriority: medium
ms.openlocfilehash: 85bc7d2135cfb25c4a93f612db6aa6e2a57eef36
ms.sourcegitcommit: 4b7a6ac7c68e6ad6f27da5d1dc4deabd5d34b748
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/24/2019
ms.locfileid: "72841481"
---
# <a name="buffer-handling"></a>バッファー処理


## <span id="ddk_buffer_handling_if"></span><span id="DDK_BUFFER_HANDLING_IF"></span>


ドライバー内の最も一般的なエラーは、バッファーが無効であるか小さすぎるバッファー処理に関連している可能性があります。 これらのエラーにより、バッファーオーバーフローが発生したり、システムクラッシュが発生したりする可能性があります。これにより、システムのセキュリティが侵害されます。

ドライバーの観点から見ると、バッファーには次の2種類があります。

-   ページングされたバッファー。メモリ内に存在していても、存在しない場合もあります。

-   非ページバッファー。メモリに常駐している必要があります。

もちろん、無効なアドレスはページングも非ページでもありませんが、オペレーティングシステムは、バッファーの原因であるページフォールトを解決するために動作を開始するので、無効なアドレスを "標準" アドレス範囲の1つ (ページングされたカーネルアドレス) に分離します。非ページカーネルアドレスまたはユーザーアドレス) を入力すると、適切な種類のエラーが発生します。 バッファーエラーが発生するのは、常にバグチェック (ページ\_FAULT\_(\_非ページ\_領域)、または例外 (状態\_アクセス\_違反など) によって処理されます。 バグチェックの場合、システムは操作を停止します。 例外が発生した場合、スタックベースの例外ハンドラーが呼び出され、いずれも例外を処理しないと、バグチェックが呼び出されます。

に関係なく、ドライバーがバグチェックにつながる原因となるアプリケーションプログラムによって呼び出される可能性のあるアクセスパスは、ドライバー内でのセキュリティ違反です。 これにより、アプリケーションはシステム全体に対してサービス拒否攻撃を行うことができます。

この領域における最も一般的な問題の1つは、ドライバーの作成者が運用環境について多くのことを想定していることです。 次のようなことが考えられます。

-   上位ビットがアドレスに設定されていることを確認しています。 これは、Boot.ini ファイルで/3GB オプションを設定することによって、システムが 4 Gb のチューニング (4GT) を使用している x86 ベースのコンピューターでは機能しません。 この場合、ユーザーモードアドレスによって、アドレス空間の3ギガバイト (GB) の上位ビットが設定されます。

-   [**ProbeForRead**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread)と[**ProbeForWrite**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite)を使用してアドレスを検証します。 これにより、プローブ時のアドレスが有効なユーザーモードアドレスであることが確認されますが、プローブ操作後も有効なままにする必要があるものはありません。 そのため、この手法では、定期的に再現可能なクラッシュにつながる可能性がある微妙な競合状態が導入されます。 **ProbeForRead**と**ProbeForWrite**の呼び出しは、さまざまな理由で必要になります。アドレスがユーザーモードアドレスであり、バッファーの長さがユーザーアドレス範囲内であるかどうかを検証するためです。 プローブが省略されている場合、ユーザーは有効なカーネルモードアドレスを渡すことができます。これは \_でキャッチされません。\_try と \_(構造化例外処理) を除き、\_は大規模なセキュリティホールを開きます。 したがって、 **ProbeForRead**と**ProbeForWrite**の呼び出しはアラインメントを保証するために必要であり、ユーザーモードアドレスと長さを組み合わせて、ユーザーアドレスの範囲内にあることを確認する必要があります。 ただし、アクセスを保護するためにブロックが必要であることを除いて、\_\_try と \_\_。

    [**ProbeForRead**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread)では、メモリアドレスが有効であるかどうかにかかわらず、使用可能なユーザーモードアドレス範囲 (たとえば、4gt を使用しないシステムでは 2 GB 未満) にアドレスと長さが含まれていることのみが検証されることに注意してください。 これに対して、 [**ProbeForWrite**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite)は、指定された長さの各ページの最初のバイトへのアクセスを試み、これらが有効なメモリアドレスであることを確認します。

-   アドレスが有効であることを確認するために、メモリマネージャー関数 (たとえば、[**M誤 Addressvalid**](https://docs.microsoft.com/windows-hardware/drivers/ddi/ntddk/nf-ntddk-mmisaddressvalid)) に依存します。 プローブ関数と同様に、これにより、再現性可能なクラッシュにつながる可能性がある競合状態が導入されます。

-   構造化例外処理を使用できません。 \_\_try および\_\_は、コンパイラ内の関数を除き、例外処理にオペレーティングシステムレベルのサポートを使用します。 カーネルレベルでの例外は、 [**ExRaiseStatus**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-exraisestatus)または関連する関数のいずれかを呼び出すことによってスローされます。 例外を発生させる可能性のある呼び出しに対して構造化例外処理を使用しないドライバーでは、バグチェックが発生します (通常、KMODE\_例外\_\_処理されません)。

    エラーを発生させることが想定されていないコードの周囲に構造化例外処理を使用することは誤りであることに注意してください。 これは、実際に検出されるバグをマスクするだけです。 \_\_使用する\_\_と、ルーチンの最上位ディスパッチレベルのラッパーを除き、この問題に対する適切な解決策ではありませんが、これはリフレックスソリューションがドライバーライターによって試行されることもあります。

-   残りのユーザーメモリの内容に依存しています。 たとえば、ドライバーがユーザーモードのメモリ位置に値を書き込み、後で同じルーチンでそのメモリ位置を参照しているとします。 悪意のあるアプリケーションによってそのメモリが積極的に変更され、その結果、ドライバーがクラッシュする可能性があります。

ファイルシステムの場合、これらの問題は、通常、ユーザーバッファーに直接アクセスすることに依存しているため、特に深刻です (メソッド\_転送方法はありません)。 このようなドライバーはユーザーバッファーを直接操作するため、オペレーティングシステムレベルのクラッシュを防ぐために、バッファー処理のための予防メソッドを組み込む必要があります。 高速 i/o では常に生のメモリポインターが渡されるため、高速 i/o がサポートされている場合、ドライバーは同様の問題から保護する必要があります。

WDK には、FASTFAT および CDFS ファイルシステムのサンプルコードで、次のようなバッファー検証の例が多数含まれています。

-   Fastfat\\deviosup の**FatLockUserBuffer**関数は、 [**MmProbeAndLockPages**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-mmprobeandlockpages)を使用してユーザーバッファーの背後にある物理ページをロックダウンし、 **MmGetSystemAddressForMdlSafe**の[**FatMapUserBuffer**](https://docs.microsoft.com/windows-hardware/drivers/kernel/mm-bad-pointer)を使用して仮想マシンを作成します。ロックダウンされているページのマッピング。

-   Fastfat\\fsctl の**Fat Getvolumebitmap**関数は、 [**ProbeForRead**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforread)と[**ProbeForWrite**](https://docs.microsoft.com/windows-hardware/drivers/ddi/wdm/nf-wdm-probeforwrite)を使用して、最適化 API のユーザーバッファーを検証します。

-   Cdfs\\read. c では、 **Cdcommonread**関数は \_を使用します。 c では、コードを除いてユーザーバッファーをゼロにして\_try と \_を\_します。 **Cdcommonread**のサンプルコードは、try キーワードと except キーワードを使用していることに注意してください。 WDK 環境では、C のこれらのキーワードは、\_try と \_\_を除き、コンパイラの拡張機能 \_定義されています。 コードをC++使用するすべてのユーザーは、例外を適切に処理するためにネイティブコンパイラ型C++を使用する必要があります。\_\_try はキーワードですC++が、C キーワードではなく、カーネルドライバーでは無効な例外処理の形式を提供します。

 

 




